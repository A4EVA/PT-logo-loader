initSidebarItems({"constant":[["HAL_ADC_MODULE_ENABLED",""],["HAL_I2C_ERR_ADDR_NACK",""],["HAL_I2C_ERR_DATA_NACK",""],["HAL_I2C_ERR_INVAL",""],["HAL_I2C_ERR_TIMEOUT",""],["HAL_I2C_ERR_UNKNOWN",""],["HAL_SPI_LSB_FIRST",""],["HAL_SPI_MODE0",""],["HAL_SPI_MODE1",""],["HAL_SPI_MODE2",""],["HAL_SPI_MODE3",""],["HAL_SPI_MSB_FIRST",""],["HAL_SPI_TYPE_MASTER",""],["HAL_SPI_TYPE_SLAVE",""],["HAL_SPI_WORD_SIZE_8BIT",""],["HAL_SPI_WORD_SIZE_9BIT",""],["hal_gpio_irq_trigger_HAL_GPIO_TRIG_BOTH","IRQ occurs on either edge"],["hal_gpio_irq_trigger_HAL_GPIO_TRIG_FALLING","IRQ occurs on falling edge"],["hal_gpio_irq_trigger_HAL_GPIO_TRIG_HIGH","IRQ occurs when line is high"],["hal_gpio_irq_trigger_HAL_GPIO_TRIG_LOW","IRQ occurs when line is low"],["hal_gpio_irq_trigger_HAL_GPIO_TRIG_NONE",""],["hal_gpio_irq_trigger_HAL_GPIO_TRIG_RISING","IRQ occurs on rising edge"],["hal_gpio_mode_e_HAL_GPIO_MODE_IN","Input"],["hal_gpio_mode_e_HAL_GPIO_MODE_NC","Not connected"],["hal_gpio_mode_e_HAL_GPIO_MODE_OUT","Output"],["hal_gpio_pull_HAL_GPIO_PULL_DOWN","Pull-down enabled"],["hal_gpio_pull_HAL_GPIO_PULL_NONE","Pull-up/down not enabled"],["hal_gpio_pull_HAL_GPIO_PULL_UP","Pull-up enabled"]],"fn":[["hal_gpio_deinit","Deinitialize the specified pin to revert the previous initialization"],["hal_gpio_init_in","Initializes the specified pin as an input"],["hal_gpio_init_out","Initialize the specified pin as an output, setting the pin to the specified value."],["hal_gpio_irq_disable","Disable IRQs on the passed pin"],["hal_gpio_irq_enable","Enable IRQs on the passed pin"],["hal_gpio_irq_init","Initialize a given pin to trigger a GPIO IRQ callback."],["hal_gpio_irq_release","Release a pin from being configured to trigger IRQ on state change."],["hal_gpio_read","Reads the specified pin."],["hal_gpio_toggle","Toggles the specified pin"],["hal_gpio_write","Write a value (either high or low) to the specified pin."],["hal_i2c_config","Configure I2C controller"],["hal_i2c_disable","Disable I2C controller"],["hal_i2c_enable","Enable I2C controller"],["hal_i2c_init","Initialize a new i2c device with the I2C number."],["hal_i2c_init_hw","Initialize I2C controller"],["hal_i2c_master_probe","Probes the i2c bus for a device with this address.  THIS API issues a start condition, probes the address using a read command and issues a stop condition."],["hal_i2c_master_read","Sends a start condition and reads  bytes of data on the i2c bus. This API does NOT issue a stop condition unless `last_op` is set to `1`. You must stop the bus after successful or unsuccessful write attempts. This API is blocking until an error or NaK occurs. Timeout is platform dependent."],["hal_i2c_master_write","Sends a start condition and writes  bytes of data on the i2c bus. This API does NOT issue a stop condition unless `last_op` is set to `1`. You must stop the bus after successful or unsuccessful write attempts. This API is blocking until an error or NaK occurs. Timeout is platform dependent."],["hal_spi_abort","This aborts the current transfer but keeps the spi enabled."],["hal_spi_config","Configure the spi. Must be called after the spi is initialized (after hal_spi_init is called) and when the spi is disabled (user must call hal_spi_disable if the spi has been enabled through hal_spi_enable prior to calling this function). Can also be used to reconfigure an initialized SPI (assuming it is disabled as described previously)."],["hal_spi_data_mode_breakout","Extracts CPOL and CPHA values from a data-mode constant. Utility function, defined once for every MCU."],["hal_spi_disable","Disables the SPI. Used for power mgmt. It will halt any current SPI transfers in progress."],["hal_spi_enable","Enables the SPI. This does not start a transmit or receive operation; it is used for power mgmt. Cannot be called when a SPI transfer is in progress."],["hal_spi_init","Initialize the SPI, given by spi_num."],["hal_spi_init_hw","Initialize SPI controller"],["hal_spi_set_txrx_cb","Sets the txrx callback (executed at interrupt context) when the buffer is transferred by the master or the slave using the non-blocking API. Cannot be called when the spi is enabled. This callback will also be called when chip select is de-asserted on the slave."],["hal_spi_slave_set_def_tx_val","Sets the default value transferred by the slave. Not valid for master"],["hal_spi_tx_val","Blocking call to send a value on the SPI. Returns the value received from the SPI slave."],["hal_spi_txrx","Blocking interface to send a buffer and store the received values from the slave. The transmit and receive buffers are either arrays of 8-bit (uint8_t) values or 16-bit values depending on whether the spi is configured for 8 bit data or more than 8 bits per value. The 'cnt' parameter is the number of 8-bit or 16-bit values. Thus, if 'cnt' is 10, txbuf/rxbuf would point to an array of size 10 (in bytes) if the SPI is using 8-bit data; otherwise txbuf/rxbuf would point to an array of size 20 bytes (ten, uint16_t values)."],["hal_spi_txrx_noblock","Non-blocking interface to send a buffer and store received values. Can be used for both master and slave SPI types. The user must configure the callback (using hal_spi_set_txrx_cb); the txrx callback is executed at interrupt context when the buffer is sent."]],"struct":[["hal_i2c_hw_settings","I2C controller hardware settings"],["hal_i2c_master_data","When sending a packet, use this structure to pass the arguments."],["hal_i2c_settings","I2C configuration"],["hal_spi_hw_settings","SPI controller hardware settings"],["hal_spi_settings","since one spi device can control multiple devices, some configuration can be changed on the fly from the hal"]],"type":[["__uint16_t",""],["__uint32_t",""],["__uint8_t",""],["hal_gpio_irq_handler_t",""],["hal_gpio_irq_trigger",""],["hal_gpio_mode_e","The \"mode\" of the gpio. The gpio is either an input, output, or it is \"not connected\" (the pin specified is not functioning as a gpio)"],["hal_gpio_pull",""],["hal_spi_txrx_cb",""]]});