<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>MCUBoot Bootloader for PineTime Smart Watch (nRF52)</title>

    
    <!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<!-- TODO -->
<meta property="og:image" content="https://lupyuen.github.io/images/mcuboot-photo2-small.jpg">
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">MCUBoot Bootloader for PineTime Smart Watch (nRF52)</h1>
    <nav id="TOC"><ul>
<li><a href="#updated-flash-memory-map-for-pinetime">1 Updated Flash Memory Map for PineTime</a><ul></ul></li>
<li><a href="#blasting-graphics-to-st7789-display-controller-on-pinetime">2 Blasting Graphics to ST7789 Display Controller on PineTime</a><ul>
<li><a href="#initialise-the-display">2.1 Initialise The Display</a><ul></ul></li>
<li><a href="#draw-a-line">2.2 Draw A Line</a><ul></ul></li></ul></li>
<li><a href="#render-boot-graphic-from-spi-flash-on-pinetime">3 Render Boot Graphic from SPI Flash on PineTime</a><ul></ul></li>
<li><a href="#write-boot-graphic-to-spi-flash-on-pinetime">4 Write Boot Graphic to SPI Flash on PineTime</a><ul></ul></li>
<li><a href="#pinetime-boot-library">5 PineTime Boot Library</a><ul></ul></li>
<li><a href="#manual-firmware-rollback-on-pinetime">6 Manual Firmware Rollback on PineTime</a><ul></ul></li>
<li><a href="#test-mcuboot-on-pinetime">7 Test MCUBoot on PineTime</a><ul></ul></li>
<li><a href="#further-reading">8 Further Reading</a><ul></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/mcuboot-photo2-small.jpg" alt="Enhanced MCUBoot Bootloader running on PineTime Smart Watch" /></p>
<p><em>Enhanced MCUBoot Bootloader running on PineTime Smart Watch</em></p>
<p>Today we'll talk about the <strong>Enhanced MCUBoot Bootloader</strong> for <a href="https://wiki.pine64.org/index.php/PineTime"><strong>PineTime Smart Watch</strong></a>. </p>
<p>Here's a sneak peek of the Enhanced MCUBoot Bootloader running on PineTime...</p>
<p><a href="https://twitter.com/MisterTechBlog/status/1261568945728876544?s=20">Watch video on Twitter</a></p>
<p><a href="https://qoto.org/@lupyuen/104177098953236703">Watch video on Mastodon</a></p>
<p>We'll learn how the open-source MCUBoot Bootloader (<a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu">covered in an earlier article</a>) has been enhanced to support...</p>
<ol>
<li>
<p><strong>SPI Flash</strong> for storing the Standby Firmware Image</p>
</li>
<li>
<p><strong>Rendering the Boot Graphic</strong> that's stored in SPI Flash </p>
<p><em>(Because PineTime Owners should have the freedom to customise the way it looks!)</em></p>
</li>
<li>
<p><strong>Manual Firmware Rollback</strong> when the watch button is pressed during startup</p>
</li>
</ol>
<p><em>...Without making any code changes to MCUBoot! (Amazing!)</em></p>
<p>We'll see that the enhancements to MCUBoot were done through configuration files, and by adding some new functions.</p>
<p><em>Isn't it easier to fork MCUBoot and change the code?</em></p>
<p>We shall always resist the temptation to modify MCUBoot code... Because MCUBoot is a <strong>Critical and Secure</strong> part of PineTime!</p>
<ol>
<li>
<p>MCUBoot must <strong>not be allowed to crash or hang</strong> due to buggy code.</p>
<p>MCUBoot is the first thing that runs when PineTime starts up. If MCUBoot crashes or hangs, PineTime Owners will have a bricked watch on their wrists.</p>
</li>
<li>
<p>MCUBoot is designed to <strong>start firmware securely,</strong> protected by digital signatures.</p>
<p>Although we don't secure PineTime firmware today, MCUBoot may someday be used to verify that our firmware hasn't been tampered with.</p>
<p><em>(Because the data collected by our smart watches may be misused to harm us someday)</em></p>
</li>
</ol>
<h1 id="updated-flash-memory-map-for-pinetime" class="section-header"><a href="#updated-flash-memory-map-for-pinetime">1 Updated Flash Memory Map for PineTime</a></h1>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu">If you haven't read the earlier article on MCUBoot... Please do so now!</a></p>
<p>Our earlier design for MCUBoot hit a showstopper... The Application Firmware size was limited to <strong>232 KB</strong>, which is too small acccording to PineTime Firmware Developers.</p>
<p>With Enhanced MCUBoot, we can now support firmware twice that size... Up to <strong>464 KB</strong>!  (Remember that PineTime's Flash ROM is only 512 KB)</p>
<p><em>How did we get so much ROM space?</em></p>
<p>We moved the Standby Firmware Image from PineTime's Flash ROM (512 KB) to PineTime's SPI Flash (4 MB).</p>
<p>During firmware update, the Standby Firmware slot is used as the staging area for the new firmware. On reboot, MCUBoot swaps the new firmware with the old firmware. If the new firmware doesn't start properly, MCUBoot swaps them back.</p>
<p>Here's the updated Flash Memory Map for PineTime. Note that the Standby Firmware Image is now stored in Flash Device 1 (SPI Flash) instead of Flash Device 0 (Internal ROM): <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/bsp.yml"><code>hw/bsp/nrf52/bsp.yml</code></a></p>
<pre><code class="language-yaml"># Flash Memory Map for PineTime: Internal Flash ROM and External SPI Flash
bsp.flash_map:
    areas:
        # System areas.
        FLASH_AREA_BOOTLOADER:       # MCUBoot
            device:  0               # Internal Flash ROM
            offset:  0x00000000      # Start of Internal Flash ROM
            size:    24kB
        FLASH_AREA_IMAGE_0:          # Active Firmware Image
            device:  0               # Internal Flash ROM
            offset:  0x00008000
            size:    464kB           # Max size of Firmware Image
        FLASH_AREA_IMAGE_1:          # Standby Firmware Image
            device:  1               # External SPI Flash
            offset:  0x00040000
            size:    464kB           # Max size of Firmware Image
        FLASH_AREA_IMAGE_SCRATCH:    # Used by MCUBoot for swapping Active and Standby Firmware
            device:  0               # Internal Flash ROM
            offset:  0x0007c000
            size:    4kB

        # User areas.
        FLASH_AREA_REBOOT_LOG:       # For logging debug messages during startup
            user_id: 0
            device:  0               # Internal Flash ROM
            offset:  0x00006000
            size:    8kB
        # FLASH_AREA_BOOTLOADER_ASSET: # Bootloader Assets, like Boot Graphic
        #   user_id: 1
        #   device:  1               # External SPI Flash
        #   offset:  0x00000000      # Start of External SPI Flash
        #   size:    256kB
        FLASH_AREA_NFFS:             # For user files
            user_id: 1
            device:  1               # External SPI Flash
            offset:  0x000b4000
            size:    3376kB
</code></pre>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/spiflash">More about PineTime's SPI Flash</a></p>
<p>Here's the layout for <strong>PineTime's Flash ROM</strong>...</p>
<table><thead><tr><th align="left">     Flash ROM Area</th><th align="left">Address</th><th align="right">Size</th></tr></thead><tbody>
<tr><td align="left">     Bootloader (MCUBoot)</td><td align="left"><code>0x0000 0000</code></td><td align="right">24 KB</td></tr>
<tr><td align="left">     Reboot Log</td><td align="left"><code>0x0000 6000</code></td><td align="right">8 KB</td></tr>
<tr><td align="left">     <strong>Active Firmware Image</strong>      </td><td align="left"><strong><code>0x0000 8000</code></strong></td><td align="right">    <strong>464 KB</strong></td></tr>
<tr><td align="left">     Scratch Area</td><td align="left"><code>0x0007 C000</code></td><td align="right">4 KB</td></tr>
<tr><td align="left"><br></td><td align="left"></td><td align="right"></td></tr>
</tbody></table>
<p>And the layout for <strong>PineTime's SPI Flash</strong>...</p>
<table><thead><tr><th align="left">     SPI Flash Area</th><th align="left">Address</th><th align="right">Size</th></tr></thead><tbody>
<tr><td align="left">     Bootloader Assets</td><td align="left"><code>0x0000 0000</code></td><td align="right">256 KB</td></tr>
<tr><td align="left">     <em>Standby Firmware Image</em>     </td><td align="left"><code>0x0004 0000</code></td><td align="right"><em>464 KB</em></td></tr>
<tr><td align="left">     User File System</td><td align="left"><code>0x000B 4000</code></td><td align="right">     3,376 KB</td></tr>
<tr><td align="left"><br></td><td align="left"></td><td align="right"></td></tr>
</tbody></table>
<p>The <strong>User File System</strong> has been bumped up to a whopping <strong>3.2 MB</strong> (from 12 KB).</p>
<p>PineTime Watch Apps may store graphical assets and other app data in the User File System, once we install a Flash File System like littlefs.</p>
<p><a href="https://github.com/ARMmbed/littlefs/blob/master/README.md">More about littlefs</a></p>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/spiflash">Supporting littlefs on PineTime</a></p>
<p><em>Bootloader Assets (256 KB) is a new flash area in SPI Flash. What's inside?</em></p>
<p>The Enhanced MCUBoot Bootloader now renders a Boot Graphic that's 112.5 KB in size. The Boot Graphic is stored in the <strong>Bootloader Assets</strong> flash area.</p>
<p>Half of the Bootloader Assets area is unused. We expect to use the free space to store fonts and other graphical assets that will be rendered by Enhanced MCUBoot.</p>
<p>The Bootloader Assets area doesn't use any Flash File System (like littlefs). We'll learn why in a while.</p>
<p>Let's discover how PineTime's ST7789 Display Controller renders graphics...</p>
<h1 id="blasting-graphics-to-st7789-display-controller-on-pinetime" class="section-header"><a href="#blasting-graphics-to-st7789-display-controller-on-pinetime">2 Blasting Graphics to ST7789 Display Controller on PineTime</a></h1>
<p>Watch how Enhanced MCUBoot renders the Boot Graphic (hand-drawn PineTime logo) before starting the Application Firmware (&quot;<code>I AM PINETIME</code>&quot;)...</p>
<p><a href="https://twitter.com/MisterTechBlog/status/1261568945728876544?s=20">Watch video on Twitter</a></p>
<p><a href="https://qoto.org/@lupyuen/104177098953236703">Watch video on Mastodon</a></p>
<p>Enhanced MCUBoot needs to render the Boot Graphic the <strong>quickest and most reliable</strong> way possible because...</p>
<ol>
<li>
<p>PineTime Owners will see this every time PineTime powers on, so it must be quick</p>
</li>
<li>
<p>The rendering must not crash MCUBoot, even when SPI Flash is corrupted</p>
<p>(<em>Yes the Boot Graphic may look really awful, but PineTime must always boot!</em>)</p>
</li>
<li>
<p>And the rendering needs to be done within the 24 KB of code space allocated to Enhanced MCUBoot</p>
<p>(<em>Which means we'll have to make assumptions and hard code certain things</em>)</p>
</li>
</ol>
<p>Let's read the code in Enhanced MCUBoot and understand how it renders the Boot Graphic quickly and reliably: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a></p>
<h2 id="initialise-the-display" class="section-header"><a href="#initialise-the-display">2.1 Initialise The Display</a></h2>
<pre><code class="language-c">#define DISPLAY_CS   25  //  GPIO Pin 25 for LCD_CS (P0.25): Chip select
#define DISPLAY_DC   18  //  GPIO Pin 18 for LCD_RS (P0.18): Clock/data pin (CD)
#define DISPLAY_RST  26  //  GPIO Pin 26 for LCD_RESET (P0.26): Display reset
#define DISPLAY_HIGH 23  //  GPIO Pin 23 for LCD_BACKLIGHT_HIGH (23): High backlight (active low)

/// Initialise the ST7789 display controller
static int init_display(void) {
    //  Assume that SPI port 0 has been initialised by the SPI Flash Driver at startup.
    hal_gpio_init_out(DISPLAY_RST, 1);  //  Configure GPIO Pin for output
    hal_gpio_init_out(DISPLAY_CS, 1);
    hal_gpio_init_out(DISPLAY_DC, 0);
    hal_gpio_init_out(DISPLAY_HIGH, 0);  //  Switch on backlight

    hard_reset();  //  Reset the display controller by toggling the Reset GPIO Pin
    write_command(SWRESET, NULL, 0); delay_ms(200);  //  Write a command and delay for 200 milliseconds
    write_command(SLPOUT, NULL, 0); delay_ms(200);

    static const uint8_t FRMCTR1_PARA[] = { 0x01, 0x2C, 0x2D };
    write_command(FRMCTR1, FRMCTR1_PARA, sizeof(FRMCTR1_PARA));

    static const uint8_t FRMCTR2_PARA[] = { 0x01, 0x2C, 0x2D };
    write_command(FRMCTR2, FRMCTR2_PARA, sizeof(FRMCTR2_PARA));

    static const uint8_t FRMCTR3_PARA[] = { 0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D };
    write_command(FRMCTR3, FRMCTR3_PARA, sizeof(FRMCTR3_PARA));

    static const uint8_t INVCTR_PARA[] = { 0x07 };
    write_command(INVCTR, INVCTR_PARA, sizeof(INVCTR_PARA));

    static const uint8_t PWCTR1_PARA[] = { 0xA2, 0x02, 0x84 };
    write_command(PWCTR1, PWCTR1_PARA, sizeof(PWCTR1_PARA));

    static const uint8_t PWCTR2_PARA[] = { 0xC5 };
    write_command(PWCTR2, PWCTR2_PARA, sizeof(PWCTR2_PARA));
    
    static const uint8_t PWCTR3_PARA[] = { 0x0A, 0x00 };
    write_command(PWCTR3, PWCTR3_PARA, sizeof(PWCTR3_PARA));
    
    static const uint8_t PWCTR4_PARA[] = { 0x8A, 0x2A };
    write_command(PWCTR4, PWCTR4_PARA, sizeof(PWCTR4_PARA));
    
    static const uint8_t PWCTR5_PARA[] = { 0x8A, 0xEE };
    write_command(PWCTR5, PWCTR5_PARA, sizeof(PWCTR5_PARA));
    
    static const uint8_t VMCTR1_PARA[] = { 0x0E };
    write_command(VMCTR1, VMCTR1_PARA, sizeof(VMCTR1_PARA));

    write_command(INVON, NULL, 0);

    static const uint8_t MADCTL1_PARA[] = { 0x00 };
    write_command(MADCTL, MADCTL1_PARA, sizeof(MADCTL1_PARA));

    static const uint8_t COLMOD_PARA[] = { 0x05 };
    write_command(COLMOD, COLMOD_PARA, sizeof(COLMOD_PARA));
    
    write_command(DISPON, NULL, 0); delay_ms(200);
    return 0;
}
</code></pre>
<p>Here's the code in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a> that initialises the <a href="https://wiki.pine64.org/images/5/54/ST7789V_v1.6.pdf"><strong>Sitronix ST7789 Display Controller</strong></a> for PineTime's 240 x 240 Colour LCD Screen. </p>
<p>At startup, the function above sends a bunch of commands and parameters to the ST7789 Display Controller via the SPI port. We send commands and data (parameters) to ST7789 in a peculiar way in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a>...</p>
<pre><code class="language-c">#define DISPLAY_SPI   0  //  ST7789 connected to SPI port 0
#define DISPLAY_DC   18  //  GPIO Pin 18 for LCD_RS (P0.18): Clock/data pin (CD)
#define DISPLAY_CS   25  //  GPIO Pin 25 for LCD_CS (P0.25): Chip select

/// Transmit ST7789 command
static int write_command(uint8_t command, const uint8_t *params, uint16_t len) {
    hal_gpio_write(DISPLAY_DC, 0);  //  Enter Command Mode
    transmit_spi(&amp;command, 1);
    if (params != NULL &amp;&amp; len &gt; 0) { write_data(params, len); }
    return 0;
}

/// Transmit ST7789 data
static int write_data(const uint8_t *data, uint16_t len) {
    hal_gpio_write(DISPLAY_DC, 1);  //  Enter Data Mode
    transmit_spi(data, len);
    return 0;
}

/// Write to the SPI port
static int transmit_spi(const uint8_t *data, uint16_t len) {    
    hal_gpio_write(DISPLAY_CS, 0);     //  Select the display controller    
    int rc = hal_spi_txrx(DISPLAY_SPI, //  Send to SPI port...
        (void *) data,                 //  Transmit Buffer
        NULL,                          //  Receive Buffer (NULL means don't receive)
        len);                          //  Length
    hal_gpio_write(DISPLAY_CS, 1);     //  De-select the display controller    
    return 0;
}
</code></pre>
<p>We toggle GPIO Pin 18 (<code>DISPLAY_DC</code>) to tell ST7789 whether we are sending a Command Byte or a sequence of Data Bytes. So in this example...</p>
<pre><code class="language-c">static const uint8_t FRMCTR1_PARA[] = { 0x01, 0x2C, 0x2D };
write_command(FRMCTR1, FRMCTR1_PARA, sizeof(FRMCTR1_PARA));
</code></pre>
<ol>
<li>
<p>We set GPIO Pin 18 to <strong>Low</strong> to transmit the <code>FRMCTR1</code> <strong>Command Byte</strong> <code>0xB1</code></p>
</li>
<li>
<p>Then set GPIO Pin 18 to <strong>High</strong> to transmit the <strong>Data Bytes</strong> <code>0x01</code>, <code>0x2C</code>, <code>0x2D</code></p>
</li>
</ol>
<p>Yes it's unusual, cumbersome and limits SPI performance. It was probably done to force-fit a 4-Line Serial Interface into the 3-Line SPI Interface.</p>
<p>Note: The above initialisation commands and parameters don't quite match up with the <a href="https://wiki.pine64.org/images/5/54/ST7789V_v1.6.pdf">ST7789 datasheet</a>. That's because the code was originally written for the <a href="https://www.displayfuture.com/Display/datasheet/controller/ST7735.pdf">ST7735 Display Controller</a>. This should be fixed, but it works on PineTime for now.</p>
<h2 id="draw-a-line" class="section-header"><a href="#draw-a-line">2.2 Draw A Line</a></h2>
<p>Let's look at the code to draw a line: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a></p>
<pre><code class="language-c">//  Set Address Window Columns (CASET)
write_command(CASET, NULL, 0);
static const uint8_t CASET2_PARA[] = { 
    0x00, 0x14,    //  From Column 20
    0x00, 0x27 };  //  To Column 39    
write_data(CASET2_PARA, sizeof(CASET2_PARA));

//  Set Address Window Rows (RASET)
write_command(RASET, NULL, 0);
static const uint8_t RASET2_PARA[] = { 
    0x00, 0x00,    //  From Row 0
    0x00, 0x00 };  //  To Row 0
write_data(RASET2_PARA, sizeof(RASET2_PARA));

//  Write Pixels (RAMWR)
write_command(RAMWR, NULL, 0);
static const uint8_t RAMWR2_PARA[] = {   //  40 bytes (20 pixels)
    0x87, 0xe0,    //  First Pixel Colour: 0x87e0 in RGB565 = Green-yellow
    0x87, 0xe0,    //  Second Pixel Colour
    ..., 
    0x87, 0xe0 };  //  20th Pixel Colour
write_data(RAMWR2_PARA, sizeof(RAMWR2_PARA));
</code></pre>
<p>To render a bitmap on the display, we send the <code>CASET</code> and <code>RASET</code> commands to define the window coordinates of the bitmap: Left (Column 20), Right (Column 39), Top (Row 0), Bottom (Row 0).</p>
<p>Then we send the <code>RAMWR</code> command followed by the pixel colours, row by row.  (Only 1 row of 20 pixels in the above example)</p>
<p>Each pixel colour consists of two bytes (like <code>0x87</code> <code>0xe0</code>), encoded in the RGB565 format.</p>
<p><a href="https://wiki.pine64.org/images/5/54/ST7789V_v1.6.pdf">See ST7789 datasheet</a></p>
<p><img src="https://lupyuen.github.io/images/mcuboot-rgb565.png" alt="RGB565" /></p>
<p>We call it RGB565 because it encodes 5 bits for Red, 6 bits for Green and 5 bits for Blue. Which adds up to 16 bits, or 2 bytes.</p>
<p><a href="https://stackoverflow.com/questions/25467682/rgb-565-why-6-bits-for-green-color">More about RGB565</a></p>
<p>For more details on PineTime's ST7789 Display Controller, check out this article...</p>
<p><a href="https://medium.com/@ly.lee/optimising-pinetimes-display-driver-with-rust-and-mynewt-3ba269ea2f5c?source=friends_link&amp;sk=4d2cbd2e6cd2343eed62d214814f7b81">Optimising PineTime’s Display Driver with Rust and Mynewt</a></p>
<p>Now that we can draw a line, let's extend the code to render the entire Boot Graphic, line by line.</p>
<h1 id="render-boot-graphic-from-spi-flash-on-pinetime" class="section-header"><a href="#render-boot-graphic-from-spi-flash-on-pinetime">3 Render Boot Graphic from SPI Flash on PineTime</a></h1>
<p>From <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a> we have seen the fastest, simplest functions to draw coloured lines with PineTime's ST7789 Display Controller.</p>
<p>Now let's call these functions to render the Boot Graphic in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a>...</p>
<pre><code class="language-c">#define BATCH_SIZE  256  //  Max number of SPI data bytes to be transmitted

//  Screen Size
#define ROW_COUNT 240
#define COL_COUNT 240
#define BYTES_PER_PIXEL 2

//  Flash Device for Image
#define FLASH_DEVICE 1  //  0 for Internal Flash ROM, 1 for External SPI Flash

/// Buffer for reading flash and writing to display
static uint8_t flash_buffer[BATCH_SIZE];

/// Display the image in SPI Flash to ST7789 display controller. 
/// Derived from https://github.com/lupyuen/pinetime-rust-mynewt/blob/main/logs/spi-non-blocking.log
int pinetime_boot_display_image(void) {
    init_display();
    set_orientation(Landscape);

    //  Render each row of pixels.
    for (uint8_t row = 0; row &lt; ROW_COUNT; row++) {
        uint8_t top = row;     //  Top row
        uint8_t bottom = row;  //  Bottom row (same as top)
        uint8_t left = 0;      //  Left column
        //  Screen Buffer: 240 * 240 * 2 / 1024 = 112.5 KB
        //  Render a batch of columns in that row.
        for (;;) {
            if (left &gt;= COL_COUNT) { break; }

            //  How many columns we will render in a batch.
            uint16_t batch_columns = BATCH_SIZE / BYTES_PER_PIXEL;
            uint16_t right = left + batch_columns - 1;
            if (right &gt;= COL_COUNT) { right = COL_COUNT - 1; }

            //  How many bytes we will transmit.
            uint16_t len = (right - left + 1) * BYTES_PER_PIXEL;

            //  Read the bytes from flash memory.
            uint32_t offset = ((top * COL_COUNT) + left) * BYTES_PER_PIXEL;
            hal_flash_read(FLASH_DEVICE, offset, flash_buffer, len);

            //  Set the display window.
            set_window(left, top, right, bottom);

            //  Write Pixels (RAMWR)
            write_command(RAMWR, NULL, 0);
            write_data(flash_buffer, len);

            //  Move to the next batch of columns.
            left = right + 1;
        }
    }
    return 0;
}
</code></pre>
<p>Note that we call <code>hal_flash_read()</code> like this to read <code>len</code> bytes starting at flash address <code>offset</code> from the SPI Flash into <code>flash_buffer</code>...</p>
<pre><code class="language-c">hal_flash_read(FLASH_DEVICE, offset, flash_buffer, len);
</code></pre>
<p>Thus the function <code>pinetime_boot_display_image()</code> above keeps reading from SPI Flash (starting at address 0) and blasts everything to the Display Controller, row by row, 256 data bytes at a time.  It's blasting the entire Boot Graphic from SPI Flash to the Display Controller!</p>
<p>Here's the <code>set_window()</code> function in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a> that sets the display window coordinates...</p>
<pre><code class="language-c">/// Set the ST7789 display window to the coordinates (left, top), (right, bottom)
static int set_window(uint8_t left, uint8_t top, uint8_t right, uint8_t bottom) {
    //  Set Address Window Columns (CASET)
    write_command(CASET, NULL, 0);
    uint8_t col_para[4] = { 0x00, left, 0x00, right };
    write_data(col_para, 4);

    //  Set Address Window Rows (RASET)
    write_command(RASET, NULL, 0);
    uint8_t row_para[4] = { 0x00, top, 0x00, bottom };
    write_data(row_para, 4);
    return 0;
}
</code></pre>
<p><em>Remember that Enhanced MCUBoot needs to render the Boot Graphic the <strong>quickest and most reliable</strong> way possible?</em></p>
<p>We have accomplished that because...</p>
<ol>
<li>
<p>The rendering code is <strong>highly predictable (or deterministic)</strong></p>
<p>The code doesn't depend on the contents of SPI Flash... It blindly blasts the bitmap data from SPI Flash to the Display Controller. Even if the SPI Flash contains garbage! (Which displays garbage, of course).</p>
<p>Thus the rendering code will always terminate (without hanging). And it won't cause MCUBoot to crash or hang.</p>
</li>
<li>
<p>We don't compress the Boot Graphic. We don't use a Flash File System either.</p>
<p>Because compression or file system bugs (or badly-formatted data) may cause MCUBoot to crash or hang</p>
</li>
<li>
<p>There is <strong>no conversion or decompression</strong> of bitmap data</p>
<p>Hence it's very fast (Watch the video again)</p>
</li>
<li>
<p>We don't allow any <strong>background processing</strong> in MCUBoot</p>
<p>No multitasking, no Bluetooth Stack. Just single-threaded code for maximum predictability and reliability.</p>
</li>
</ol>
<p>When adding functions to MCUBoot, we need to assume that multitasking (Task Scheduler) is disabled. Here's an example from <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/display.c"><code>display.c</code></a>...</p>
<pre><code class="language-c">/// Sleep for the specified number of milliseconds
static void delay_ms(uint32_t ms) {
    #if MYNEWT_VAL(OS_SCHEDULING)  //  If Task Scheduler is enabled (i.e. not MCUBoot)...
        uint32_t delay_ticks = ms * OS_TICKS_PER_SEC / 1000;
        os_time_delay(delay_ticks);
    #else  //  If Task Scheduler is disabled (i.e. MCUBoot)...
        //  os_time_delay() doesn't work in MCUBoot because the Task Scheduler isn't started
        pinetime_boot_check_button();
    #endif  //  MYNEWT_VAL(OS_SCHEDULING)
}
</code></pre>
<p>Some system functions like <code>os_time_delay()</code> only work when the Task Scheduler is enabled. Since multitasking is disabled for MCUBoot, we'll have to use an alternative function like <code>pinetime_boot_check_button()</code>. </p>
<p>We'll cover <code>pinetime_boot_check_button()</code> in a while.</p>
<p>How shall we load a PNG graphic file to PineTime's SPI Flash as the Boot Graphic? We'll find out next.</p>
<h1 id="write-boot-graphic-to-spi-flash-on-pinetime" class="section-header"><a href="#write-boot-graphic-to-spi-flash-on-pinetime">4 Write Boot Graphic to SPI Flash on PineTime</a></h1>
<p>TODO</p>
<p>https://github.com/lupyuen/pinetime-graphic</p>
<p>https://github.com/lupyuen/pinetime-graphic/blob/master/src/main.rs</p>
<pre><code class="language-bash">git clone https://github.com/lupyuen/pinetime-graphic
cd pinetime-graphic
cargo build
cargo run -v pinetime-graphic.png
</code></pre>
<p>https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/write.c</p>
<pre><code class="language-c">#define BATCH_SIZE  4096  //  Max number of data bytes to be written in a batch
#define FLASH_DEVICE 1    //  Flash Device: 0 for Flash ROM, 1 for SPI Flash

//  Converted from PNG file by https://github.com/lupyuen/pinetime-graphic
static const uint8_t image_data[] = {  //  Should be 115,200 bytes
#include &quot;graphic.inc&quot;
};

/// Write a converted graphic file to SPI Flash
int pinetime_boot_write_image(void) {
    uint32_t offset = 0;
    for (;;) {
        if (offset &gt;= sizeof(image_data)) { break; }
        //  How many bytes we will write.
        uint16_t len = BATCH_SIZE;
        if (offset + len &gt;= sizeof(image_data)) {
            len = sizeof(image_data) - offset;
        }        
        //  Erase the bytes.
        int rc = hal_flash_erase(FLASH_DEVICE, offset, len); assert(rc == 0);

        //  Write the bytes.
        rc = hal_flash_write(FLASH_DEVICE, offset, (void *) &amp;image_data[offset], len); assert(rc == 0);
        offset += len;
    }
    return 0;
}
</code></pre>
<p>https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/libs/pinetime_boot/src/graphic.inc</p>
<p>115,200 bytes</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
...
<span class="number">0x05</span>, <span class="number">0xa3</span>, <span class="number">0x01</span>, <span class="number">0x20</span>, <span class="number">0x01</span>, <span class="number">0x20</span>, <span class="number">0x01</span>, <span class="number">0x20</span>, <span class="number">0x06</span>, <span class="number">0xe4</span>, <span class="number">0x07</span>, <span class="number">0xe5</span>, <span class="number">0x07</span>, <span class="number">0xe5</span>, <span class="number">0x07</span>, <span class="number">0xe5</span>,
<span class="number">0x05</span>, <span class="number">0xe3</span>, <span class="number">0x02</span>, <span class="number">0xc1</span>, <span class="number">0x02</span>, <span class="number">0xa1</span>, <span class="number">0x03</span>, <span class="number">0x62</span>, <span class="number">0x07</span>, <span class="number">0xe5</span>, <span class="number">0x07</span>, <span class="number">0xe5</span>, <span class="number">0x07</span>, <span class="number">0xe5</span>, <span class="number">0x07</span>, <span class="number">0xc5</span>,
...</pre></div>
<p>https://github.com/lupyuen/pinetime-rust-mynewt/releases/tag/v4.1.1</p>
<h1 id="pinetime-boot-library" class="section-header"><a href="#pinetime-boot-library">5 PineTime Boot Library</a></h1>
<p>TODO</p>
<p>Two spots to hook on to MCUBoot...</p>
<ol>
<li>
<p>Start of MCUBoot</p>
</li>
<li>
<p>End of MCUBoot</p>
</li>
</ol>
<h1 id="manual-firmware-rollback-on-pinetime" class="section-header"><a href="#manual-firmware-rollback-on-pinetime">6 Manual Firmware Rollback on PineTime</a></h1>
<p>TODO</p>
<h1 id="test-mcuboot-on-pinetime" class="section-header"><a href="#test-mcuboot-on-pinetime">7 Test MCUBoot on PineTime</a></h1>
<p>TOOD</p>
<p>https://github.com/lupyuen/pinetime-rust-mynewt/releases/tag/v4.1.1</p>
<ol>
<li>
<p>mynewt.*: Enhanced Build of MCUBoot Bootloader 1.5.0, supports Boot Graphic and SPI Flash</p>
</li>
<li>
<p>my_sensor_app.*: Application Firmware that supports firmware upgrade over Bluetooth.</p>
</li>
<li>
<p>pinetime-rust-mynewt.7z: Complete set of build files generated on macOS</p>
</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Starting</span> <span class="ident">Bootloader</span>...
<span class="ident">Displaying</span> <span class="ident">image</span>...
<span class="ident">Image</span> <span class="ident">displayed</span>
<span class="ident">Button</span>: <span class="number">0</span>
[<span class="ident">INF</span>] <span class="ident">Primary</span> <span class="ident">image</span>: <span class="ident">magic</span><span class="op">=</span><span class="ident">unset</span>, <span class="ident">swap_type</span><span class="op">=</span><span class="number">0x1</span>, <span class="ident">copy_done</span><span class="op">=</span><span class="number">0x3</span>, <span class="ident">image_ok</span><span class="op">=</span><span class="number">0x3</span>
[<span class="ident">INF</span>] <span class="ident">Scratch</span>: <span class="ident">magic</span><span class="op">=</span><span class="ident">unset</span>, <span class="ident">swap_type</span><span class="op">=</span><span class="number">0x1</span>, <span class="ident">copy_done</span><span class="op">=</span><span class="number">0x3</span>, <span class="ident">image_ok</span><span class="op">=</span><span class="number">0x3</span>
[<span class="ident">INF</span>] <span class="ident">Boot</span> <span class="ident">source</span>: <span class="ident">primary</span> <span class="ident">slot</span>
[<span class="ident">INF</span>] <span class="ident">Swap</span> <span class="kw">type</span>: <span class="ident">none</span>
<span class="ident">Button</span>: <span class="number">0</span>
<span class="ident">Button</span>: <span class="number">0</span>
<span class="ident">Bootloader</span> <span class="ident">done</span>
<span class="ident">TMP</span> <span class="ident">create</span> <span class="ident">temp_stub_0</span>
<span class="ident">NET</span> <span class="ident">hwid</span> <span class="number">4a</span> <span class="ident">f8</span> <span class="ident">cf</span> <span class="number">95</span> <span class="number">6a</span> <span class="ident">be</span> <span class="ident">c1</span> <span class="ident">f6</span> <span class="number">89</span> <span class="ident">ba</span> <span class="number">12</span> <span class="number">1a</span> 
<span class="ident">NET</span> <span class="ident">standalone</span> <span class="ident">node</span> 
<span class="ident">Testing</span> <span class="ident">flash</span>...
<span class="ident">Read</span> <span class="ident">Internal</span> <span class="ident">Flash</span> <span class="ident">ROM</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x20</span> <span class="number">0xd9</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0008</span>: <span class="number">0x35</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x37</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0010</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0018</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
<span class="ident">Read</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0008</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0010</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0018</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
<span class="ident">Flash</span> <span class="ident">OK</span>
<span class="ident">Rust</span> <span class="ident">test</span> <span class="ident">display</span></pre></div>
<h1 id="further-reading" class="section-header"><a href="#further-reading">8 Further Reading</a></h1>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/README.md">Check out the other PineTime articles</a></p>

    
</body>
</html>