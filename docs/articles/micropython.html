<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Porting MicroPython and wasp-os to Mynewt on PineTime Smart Watch (nRF52)</title>

    
    <!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<!-- TODO -->
<meta property="og:image" content="https://lupyuen.github.io/images/micropython-title.jpg">
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Porting MicroPython and wasp-os to Mynewt on PineTime Smart Watch (nRF52)</h1>
    <nav id="TOC"><ul>
<li><a href="#better-micropython-and-wasp-os-on-pinetime">1 Better MicroPython and wasp-os on PineTime</a><ul></ul></li>
<li><a href="#host-micropython-and-wasp-os-on-mynewt">2 Host MicroPython and wasp-os on Mynewt</a><ul></ul></li>
<li><a href="#hardware-abstraction-layer-for-pinetime">3 Hardware Abstraction Layer for PineTime</a><ul></ul></li>
<li><a href="#mynewt-port-for-micropython">4 Mynewt Port for MicroPython</a><ul>
<li><a href="#configuration">4.1 Configuration</a><ul></ul></li>
<li><a href="#peripheral-drivers-gpio-i2c-spi">4.2 Peripheral Drivers: GPIO, I2C, SPI</a><ul></ul></li>
<li><a href="#other-drivers">4.3 Other Drivers</a><ul></ul></li>
<li><a href="#start-micropython">4.4 Start MicroPython</a><ul></ul></li>
<li><a href="#reset-handler-vector-table-and-linker-script">4.5 Reset Handler, Vector Table and Linker Script</a><ul></ul></li></ul></li>
<li><a href="#gpio-driver">5 GPIO Driver</a><ul></ul></li>
<li><a href="#spi-driver">6 SPI Driver</a><ul></ul></li>
<li><a href="#i2c-driver">7 I2C Driver</a><ul></ul></li>
<li><a href="#heap-memory">8 Heap Memory</a><ul></ul></li>
<li><a href="#semihosting-console">9 Semihosting Console</a><ul></ul></li>
<li><a href="#bluetooth-driver">10 Bluetooth Driver</a><ul></ul></li>
<li><a href="#task-scheduler">11 Task Scheduler</a><ul></ul></li>
<li><a href="#vscode-workspace">12 VSCode Workspace</a><ul></ul></li>
<li><a href="#debug-with-vscode-and-st-link">13 Debug with VSCode and ST-Link</a><ul></ul></li>
<li><a href="#testing-wasp-os-and-micropython-with-mynewt">14 Testing wasp-os and MicroPython with Mynewt</a><ul></ul></li>
<li><a href="#further-reading">15 Further Reading</a><ul></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/micropython-title.jpg" alt="MicroPython and wasp-os hosted on Mynewt on PineTime Smart Watch. VSCode Debugger is shown on the monitor" /></p>
<p><em>MicroPython and wasp-os hosted on Mynewt on PineTime Smart Watch. VSCode Debugger is shown on the monitor</em></p>
<p><a href="https://wasp-os.readthedocs.io/en/latest/README.html"><strong>wasp-os</strong></a>, built with <a href="https://micropython.org/"><strong>MicroPython</strong></a>, is highly popular with folks coding <a href="https://wiki.pine64.org/index.php/PineTime"><strong>PineTime Smart Watch</strong></a> for the very first time...</p>
<p><em>Because there's no easier way to create a Watch App for PineTime!</em></p>
<p>Just write a simple Python script, upload it wirelessly to wasp-os and watch it run!</p>
<p>And if the script doesn't work right? Just connect over Bluetooth and troubleshoot live with the REPL (Read-Eval-Print Loop) command line!</p>
<p>Today wasp-os works great on Bare Metal (i.e. PineTime hardware). It doesn't require an embedded operating system, because the underlying MicroPython runtime serves as a bare-bones operating system.</p>
<p><img src="https://lupyuen.github.io/images/micropython-mynewt0.png" alt="MicroPython and wasp-os on PineTime" /></p>
<h1 id="better-micropython-and-wasp-os-on-pinetime" class="section-header"><a href="#better-micropython-and-wasp-os-on-pinetime">1 Better MicroPython and wasp-os on PineTime</a></h1>
<p><em>How shall we make wasp-os better?</em></p>
<p>I'm now coding these enhancements in MicroPython...</p>
<ol>
<li>
<p><strong>Easier Installation</strong></p>
<p>What if PineTime Owners can unbox their smart watches... And install wasp-os wirelessly through their phones? No more messy wiring to the SWD Port inside PineTime!</p>
<p>And we'll let PineTime Owners switch and test drive any operating system wirelessly: wasp-os, FreeRTOS, Mynewt, RIOT, Zephyr, ... Without opening their watches!</p>
<p>We're getting ready a <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">Common Bootloader</a> and <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu">Firmware Update mechanism</a> that will be preloaded by Pine64 into PineTime watches... Would be terrific to have wasp-os and MicroPython on board!</p>
<p>More about this in a while.</p>
</li>
<li>
<p><strong>PineTime Companion App for Android, iOS and PinePhone</strong></p>
<p>A common Companion App for PineTime that updates the firmware, uploads Watch Apps and lets you interact via the REPL command line... That works on Android, iOS and PinePhone!</p>
<p>If you have a Raspberry Pi, the Companion App will run too! (Using Pi's onboard Bluetooth hardware)</p>
<p>We're creating the Companion App now... And we hope to have wasp-os adopting the <a href="https://github.com/apache/mynewt-mcumgr">Simple Management Protocol</a> that's used by Mynewt, RIOT, FreeRTOS and Zephyr.</p>
<p>We have a solution for this... More about this later.</p>
</li>
<li>
<p><strong>Simpler Firmware Debugging with Raspberry Pi and VSCode</strong></p>
<p>For newbies who have mastered MicroPython programming on PineTime, perhaps they would like to dig deeper into the internals of wasp-os firmware, make some tweaks, experiment with the Bluetooth stack, ...</p>
<p>Let's make it easier for them to explore! Just connect a Raspberry Pi to PineTime's SWD Port (yep slightly messy) and step through the firmware code with the VSCode Debugger.</p>
<p>Or just study the helpful debugging messages that will be displayed in OpenOCD, thanks to the SWD Semihosting Console. </p>
<p>Check out this video of wasp-os and MicroPython debug messages displayed on the Semihosting Console with OpenOCD and VSCode...</p>
<ul>
<li>
<p><a href="https://youtu.be/_mhxvYG9Qos">Watch on YouTube</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/releases/download/v4.2.0/micropython-semihosting-rotated.mp4">Download the video</a></p>
</li>
</ul>
</li>
<li>
<p><strong>Preemptive Multitasking</strong></p>
<p>MicroPython comes with simple task management. Perhaps we should get ready to support Watch Apps that require full multitasking?</p>
<p>If we build a MicroPython Watch App that talks to other watches over Bluetooth Mesh... Surely we'll need some kind of background processing?</p>
</li>
<li>
<p><strong>Best Buddies with other Operating Systems</strong></p>
<p>PineTime feels like a rowdy playground sometimes... Kids (i.e. various PineTime Firmware) come and go as they please, messing up the sandbox (e.g. PineTime's SPI Flash) for the other players.</p>
<p>Can we turn PineTime into a safer, happier playground for all? </p>
<p>Adopting a common filesystem (like littlefs) with fixed parameters (SPI Flash location) may help.</p>
<p><img src="https://lupyuen.github.io/images/micropython-scratch.png" alt="PineTime Bootloader's Boot Graphic (stored in SPI Flash) unintentionally scratched (top left) by the firmware" /></p>
<p><em>PineTime Bootloader's Boot Graphic (stored in SPI Flash) unintentionally scratched (top left) by the firmware</em></p>
</li>
</ol>
<h1 id="host-micropython-and-wasp-os-on-mynewt" class="section-header"><a href="#host-micropython-and-wasp-os-on-mynewt">2 Host MicroPython and wasp-os on Mynewt</a></h1>
<p>To make wasp-os truly awesome with interoperable firmware updates (and a common companion app), we could add to MicroPython the following open source components...</p>
<ol>
<li>
<p><a href="https://github.com/apache/mynewt-nimble">NimBLE Bluetooth Networking Stack</a></p>
</li>
<li>
<p><a href="https://juullabs-oss.github.io/mcuboot/">MCUBoot Bootloader</a></p>
</li>
<li>
<p><a href="https://github.com/apache/mynewt-mcumgr">MCU Manager Library</a> for Simple Management Protocol</p>
</li>
<li>
<p>And a sophisticated Task Scheduler</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/micropython-mynewt1.png" alt="MicroPython and wasp-os without Mynewt" /></p>
<p><em>Looks daunting!</em></p>
<p>Or we could <strong>host wasp-os and MicroPython on Mynewt,</strong> which already includes NimBLE, MCUBoot, MCU Manager and <a href="https://mynewt.apache.org/latest/os/core_os/mynewt_os.html">Preemptive Multitasking</a>...</p>
<p><img src="https://lupyuen.github.io/images/micropython-mynewt2.png" alt="MicroPython and wasp-os hosted on Mynewt" /></p>
<p>That's the approach we'll explore. Hosting MicroPython on another operating system isn't new... It has been done with <a href="https://github.com/micropython/micropython/tree/master/ports/zephyr">Zephyr</a>, which is similar to Mynewt.</p>
<p><em>What could go wrong?</em></p>
<p>There are plenty of risks in running wasp-os and MicroPython on Mynewt instead of Bare Metal...</p>
<ol>
<li>
<p><strong>MicroPython is Dynamic, Mynewt is Not</strong></p>
<p>MicroPython allocates objects dynamically in <strong>Heap Memory.</strong> When Heap Memory runs low, the Garbage Collector sweeps the memory and reclaims space for new objects.</p>
<p>Traditional embedded operating systems are engineered to be highly predictable and less flexible. Objects live in <strong>Static Memory and Stack Memory,</strong> not in Heap Memory.</p>
<p><em>Embedded operating systems like Mynewt will get spooked by Dynamic Objects in MicroPython!</em></p>
<p>Heap Memory needs to be managed really carefully with Mynewt.</p>
</li>
<li>
<p><strong>MicroPython is blissfully unaware of Multitasking</strong></p>
<p>MicroPython runs mostly as a single task with a single stack. Easy peasy!</p>
<p>Mynewt runs with multiple tasks and multiple stacks. Tasks communicate by passing Events.</p>
<p>So it gets messy when we try to give MicroPython the illusion that it's running all alone by itself... MicroPython needs to share the CPU and RAM with Mynewt tasks now.</p>
</li>
<li>
<p><strong>wasp-os Complexity</strong></p>
<p>By inserting an embedded operating system (Mynewt) under MicroPython, it increases the complexity of the entire wasp-os firmware.</p>
<p>We'll have to manage this complexity very carefully: We shall make changes only to the MicroPython layer, not to the wasp-os layer.</p>
</li>
<li>
<p>And most ominous of all: <strong>I have failed before!</strong></p>
<p>My first hacking experience with MicroPython was on <a href="https://github.com/lupyuen/bluepill-micropython">STM32 Blue Pill</a>... It failed miserably.</p>
<p>But now I'm older, wiser and I have much better hardware (PineTime vs Blue Pill)... I might succeed!</p>
</li>
</ol>
<p>Here goes the experiment to assess whether it's really feasible to improve wasp-os by hosting it on top of Mynewt. </p>
<p>Our objective is simple: To boot up wasp-os on Mynewt and render a watch face on PineTime.</p>
<p>Read on for the details.</p>
<p><img src="https://lupyuen.github.io/images/micropython-watch.jpg" alt="Objective Accomplished! wasp-os rendering a watch face with Mynewt on PineTime. At right is the ST-Link debugger" /></p>
<p><em>Objective Accomplished! wasp-os rendering a watch face with Mynewt on PineTime. At right is the ST-Link debugger</em></p>
<h1 id="hardware-abstraction-layer-for-pinetime" class="section-header"><a href="#hardware-abstraction-layer-for-pinetime">3 Hardware Abstraction Layer for PineTime</a></h1>
<p>Embedded operating systems (like Mynewt) are designed to run on multuple hardware platforms (like PineTime). That's why they include a <a href="https://mynewt.apache.org/latest/os/modules/hal/hal.html"><strong>Hardware Abstraction Layer</strong></a> that wraps low-level <strong>hardware-specific code</strong> (like writing to SPI registers) into high-level <strong>hardware-independent functions</strong> (like sending a chunk of data to the SPI port).</p>
<p>The Hardware Abstraction Layer is used on PineTime like this...</p>
<p><img src="https://lupyuen.github.io/images/micropython-hal.png?1" alt="Hardware Abstraction Layer in PineTime" /></p>
<p>In MicroPython, the Hardware Abstraction Layers for various hardware platforms are located in the <strong>Ports</strong> folder, coded in C...</p>
<ul>
<li><strong>MicroPython Ports:</strong> <a href="https://github.com/micropython/micropython/tree/master/ports"><code>github.com/micropython/micropython/ports</code></a></li>
</ul>
<p>PineTime uses the <strong>nRF Port</strong>, which runs on nRF51 and nRF52 hardware...</p>
<ul>
<li><strong>MicroPython nRF Port:</strong> <a href="https://github.com/micropython/micropython/tree/master/ports/nrf"><code>ports/nrf</code></a></li>
</ul>
<p>For this experiment we cloned the nRF Port to create a new <strong>Mynewt Port</strong> that will run on Mynewt (instead of bare hardware)...</p>
<ul>
<li><strong>MicroPython Mynewt Port:</strong> <a href="https://github.com/AppKaki/micropython/tree/wasp-os/ports/mynewt"><code>ports/mynewt</code></a></li>
</ul>
<p>Let's look inside the Mynewt Port.</p>
<h1 id="mynewt-port-for-micropython" class="section-header"><a href="#mynewt-port-for-micropython">4 Mynewt Port for MicroPython</a></h1>
<p>Remember that a MicroPython Port works like a Hardware Abstraction Layer... It contains high-level functions for accessing the GPIO, SPI and I2C hardware interfaces.  Let's learn how the Mynewt Port of MicroPython implements these high-level functions in C.</p>
<h2 id="configuration" class="section-header"><a href="#configuration">4.1 Configuration</a></h2>
<p>Here are the configuration files for the Mynewt Port of MicroPython...</p>
<ul>
<li>
<p><a href="https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/mpconfigport.h"><code>mpconfigport.h</code></a>: Configures MicroPython Runtime features, like REPL and code compilation</p>
</li>
<li>
<p><a href="https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/boards/pinetime/mpconfigboard.h"><code>boards/pinetime/mpconfigboard.h</code></a>: Configures PineTime's Hardware features, like SPI</p>
</li>
<li>
<p><a href="https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/boards/pinetime/pins.csv"><code>boards/pinetime/pins.csv</code></a>: Defines PineTime's Hardware Pins and their functions (GPIO, SPI, I2C)</p>
</li>
</ul>
<h2 id="peripheral-drivers-gpio-i2c-spi" class="section-header"><a href="#peripheral-drivers-gpio-i2c-spi">4.2 Peripheral Drivers: GPIO, I2C, SPI</a></h2>
<p>PineTime's nRF52 Microcontroller has onboard functions like GPIO, I2C, SPI, UART, Timers, ... We call them <strong>Peripherals</strong>.</p>
<ul>
<li>
<p><a href="https://github.com/AppKaki/micropython/tree/wasp-os/ports/mynewt/modules/machine"><code>modules/machine</code></a> folder contains the driver code in C for the nRF52 Peripherals</p>
</li>
<li>
<p>We have reprogrammed the GPIO, SPI and I2C Drivers to work with Mynewt's Hardware Abstraction Layer. More about this later.</p>
</li>
<li>
<p>Peripheral Drivers from MicroPython that we haven't ported to Mynewt: Analog-to-Digital Converter, Pulse Width Modulation, Real Time Clock, Temperature Sensor, Timer, UART</p>
</li>
</ul>
<h2 id="other-drivers" class="section-header"><a href="#other-drivers">4.3 Other Drivers</a></h2>
<p>There are other MicroPython drivers for PineTime's nRF52 Microcontroller that we haven't ported to Mynewt yet. The drivers may be found in these folders...</p>
<ul>
<li>
<p><a href="https://github.com/AppKaki/micropython/tree/wasp-os/ports/mynewt/modules"><code>modules</code></a>: Bluetooth LE, LED, Music, Random Number Generator, BluePy, OS, Time</p>
</li>
<li>
<p><a href="https://github.com/AppKaki/micropython/tree/wasp-os/ports/mynewt/drivers"><code>drivers</code></a>: Bluetooth, Flash ROM, Soft PWM, Ticker, Watchdog</p>
</li>
</ul>
<h2 id="start-micropython" class="section-header"><a href="#start-micropython">4.4 Start MicroPython</a></h2>
<ul>
<li>
<p><a href="https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/main.c"><code>main.c</code></a> contains the <code>start_micropython()</code> function that starts the MicroPython Runtime (including the REPL command line)</p>
</li>
<li>
<p><code>start_micropython()</code> is called by Mynewt during startup</p>
</li>
<li>
<p>Heap Memory for MicroPython is also defined in <a href="https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/main.c"><code>main.c</code></a> as a Static Array. More about this later.</p>
</li>
</ul>
<h2 id="reset-handler-vector-table-and-linker-script" class="section-header"><a href="#reset-handler-vector-table-and-linker-script">4.5 Reset Handler, Vector Table and Linker Script</a></h2>
<p>Every PineTime Firmware requires a <strong>Reset Handler</strong> function to defined. It's the first function that's called when the firmware starts.</p>
<p>The firmware should also contain a <strong>Vector Table</strong>, which is a list of pointers to functions that will handle interrupts and exceptions on PineTime.</p>
<p>The <strong>Linker Script</strong> is used by the GCC Linker while building the firmware to determine the addresses in ROM and RAM for placing the firmware code and data.</p>
<p>The Reset Handler, Vector Table and Linker Script are mandatory for every MicroPython Port (including the nRF Port). But for the Mynewt Port, they are not used because we'll be using the Reset Handler, Vector Table and Linker Script from Mynewt instead.</p>
<ul>
<li>
<p><a href="https://github.com/AppKaki/micropython/tree/wasp-os/ports/mynewt/device"><code>device</code></a> folder contains the MicroPython Reset Handler and Vector Table</p>
<p>They are not used in the Mynewt Port, we're using the Reset Handler and Vector Table from Mynewt: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/micropython/hw/bsp/nrf52/src/arch/cortex_m4/gcc_startup_nrf52.s"><code>hw/bsp/nrf52/src/arch/cortex_m4/gcc_startup_nrf52.s</code></a></p>
</li>
<li>
<p><a href="https://github.com/AppKaki/micropython/tree/wasp-os/ports/mynewt/boards"><code>boards</code></a> folder contains the MicroPython Linker Script</p>
<p>This Linker Script is not used in the Mynewt Port, we're using the Linker Script from Mynewt: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/micropython/hw/bsp/nrf52/nrf52xxaa.ld"><code>hw/bsp/nrf52/nrf52xxaa.ld</code></a></p>
</li>
</ul>
<p>Let's study the code for the GPIO, SPI and I2C Drivers in the Mynewt Port for MicroPython... And understand how they call Mynewt's Hardware Abstraction Layer.</p>
<p><img src="https://lupyuen.github.io/images/micropython-hal1.png" alt="GPIO Driver" /></p>
<h1 id="gpio-driver" class="section-header"><a href="#gpio-driver">5 GPIO Driver</a></h1>
<p>The GPIO Driver is essential for our demo... Because PineTime's Backlight is controlled by GPIO and PineTime's screen will be totally dark without the Backlight!</p>
<p>Let's look at the current implementation of the GPIO Driver on MicroPython: <a href="https://github.com/micropython/micropython/blob/master/ports/nrf/mphalport.h"><code>ports/nrf/mphalport.h</code></a></p>
<pre><code class="language-c">#define mp_hal_pin_high(p) \
        nrf_gpio_pin_set(p-&gt;pin)

#define mp_hal_pin_low(p) \     
        nrf_gpio_pin_clear(p-&gt;pin)
</code></pre>
<p>To set a pin high or low, the GPIO Driver (from the nRF Port) calls the functions <code>nrf_gpio_pin_set()</code> and <code>nrf_gpio_pin_clear()</code>, which are provided by the <a href="https://infocenter.nordicsemi.com/topic/sdk_nrf5_v16.0.0/group__nrf__gpio__hal.html">Nordic nRF5 SDK</a></p>
<p>Clearly this GPIO Driver (nRF Port) is directly manipulating the bare hardware of PineTime.</p>
<p>Compare that with the Mynewt Port: <a href="https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/mphalport.h"><code>ports/mynewt/mphalport.h</code></a></p>
<pre><code class="language-c">#define mp_hal_pin_high(p) \
        hal_gpio_write(p-&gt;pin, 1)

#define mp_hal_pin_low(p) \
        hal_gpio_write(p-&gt;pin, 0)
</code></pre>
<p>This GPIO Driver calls the functions <code>hal_gpio_write()</code> and <code>hal_gpio_write()</code> provided by <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_gpio/hal_gpio.html"><strong>Mynewt's Hardware Abstraction Layer</strong></a>.</p>
<p>Thus we are no longer manipulating PineTime hardware directly... We are doing it through an embedded operating system (Mynewt).</p>
<p>And we get to enjoy all the benefits of the embedded operating system! Multitasking, firmware updates, Bluetooth support, ...</p>
<p>Here's how we configure and read a GPIO pin by calling <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_gpio/hal_gpio.html">Mynewt's Hardware Abstraction Layer</a>... </p>
<pre><code class="language-c">#define mp_hal_pin_read(p) \
        hal_gpio_read(p-&gt;pin)

#define mp_hal_pin_open_drain(p) \
        hal_gpio_init_in(p-&gt;pin, HAL_GPIO_PULL_NONE)
</code></pre>
<p>With this simple reprogramming, we have done enough to switch on PineTime's Backlight for our experiment.</p>
<p>Some GPIO functions have yet to be implemented, like in <a href="https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/modules/machine/pin.c"><code>modules/machine/pin.c</code></a>...</p>
<pre><code class="language-c">STATIC mp_obj_t pin_irq(
    size_t n_args, 
    const mp_obj_t *pos_args, 
    mp_map_t *kw_args) { ...
</code></pre>
<p><code>pin_irq()</code> is called by MicroPython to configure the interrupt that will be triggered when an input GPIO pin switches its state from high to low (or low to high). This will be useful for handling the pressing of PineTime's watch button, since it's connected to a GPIO pin.</p>
<p>Eventually <code>pin_irq()</code> shall be reprogrammed to call the equivalent function in Mynewt: <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_gpio/hal_gpio.html#c.hal_gpio_irq_init"><code>hal_gpio_irq_init()</code></a></p>
<p><img src="https://lupyuen.github.io/images/micropython-hal2.png" alt="SPI Driver" /></p>
<h1 id="spi-driver" class="section-header"><a href="#spi-driver">6 SPI Driver</a></h1>
<p>TODO</p>
<p>The GPIO Driver is essential for our demo... Because PineTime's Backlight is controlled by GPIO and PineTime's screen will be totally dark without the Backlight!</p>
<p>No init</p>
<p>https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/modules/machine/spi.c</p>
<pre><code class="language-c">void spi_transfer(
    const machine_hard_spi_obj_t * self, 
    size_t len, 
    const void * src, 
    void * dest
) {
    int rc = hal_spi_txrx(
        SPI_PORT, 
        (void *) src,   //  TX Buffer
        dest,           //  RX Buffer
        len             //  Length
    );
    if (rc != 0) { mp_raise_ValueError(&quot;SPI TX failed&quot;); }
}
</code></pre>
<p>https://mynewt.apache.org/latest/os/modules/hal/hal_spi/hal_spi.html#c.hal_spi_txrx</p>
<p><img src="https://lupyuen.github.io/images/micropython-hal3.png" alt="I2C Driver" /></p>
<h1 id="i2c-driver" class="section-header"><a href="#i2c-driver">7 I2C Driver</a></h1>
<p>TODO</p>
<p>The GPIO Driver is essential for our demo... Because PineTime's Backlight is controlled by GPIO and PineTime's screen will be totally dark without the Backlight!</p>
<p>https://github.com/AppKaki/micropython/blob/wasp-os/ports/mynewt/modules/machine/i2c.c</p>
<pre><code class="language-c">mp_obj_t machine_hard_i2c_make_new(
    const mp_obj_type_t *type, 
    size_t n_args, 
    size_t n_kw, 
    const mp_obj_t *all_args
) {
    struct hal_i2c_settings settings = {
        .frequency = 400,  //  Set to the highest I2C frequency 400 Kbps
    };
    int rc = hal_i2c_config(
        I2C_PORT, 
        &amp;settings
    );
    if (rc != 0) { mp_raise_ValueError(&quot;I2C init failed&quot;); }

    const machine_hard_i2c_obj_t *self = &amp;machine_hard_i2c_obj[I2C_PORT];
    return MP_OBJ_FROM_PTR(self);
}
</code></pre>
<p>https://mynewt.apache.org/latest/os/modules/hal/hal_i2c/hal_i2c.html#c.hal_i2c_config</p>
<pre><code class="language-c">/// Return the number of bytes transferred, or in case of error, a negative MP error code.
int machine_hard_i2c_transfer_single(
    mp_obj_base_t *self_in, 
    uint16_t addr, 
    size_t len, 
    uint8_t *buf, 
    unsigned int flags
) {
    struct hal_i2c_master_data master_data = {
        .address = addr,
        .len = len,
        .buffer = buf,
    };
    if (flags &amp; MP_MACHINE_I2C_FLAG_READ) {  //  If reading from I2C...
        int rc_read = hal_i2c_master_read(
            I2C_PORT, 
            &amp;master_data, 
            I2C_TIMEOUT, 
            1          //  1 means this is the last I2C operation. So we can terminate after this.
        );    
        if (rc_read != 0) { return check_i2c_return_code(rc_read); }
    } else {  //  If writing to I2C...
        int rc_write = hal_i2c_master_write(
            I2C_PORT, 
            &amp;master_data, 
            I2C_TIMEOUT, 
            1        //  1 means this is the last I2C operation. So we can terminate after this.
        );
        if (rc_write != 0) { return check_i2c_return_code(rc_write); }
    }
    return len;
}
</code></pre>
<p>https://mynewt.apache.org/latest/os/modules/hal/hal_i2c/hal_i2c.html#c.hal_i2c_master_read</p>
<p>https://mynewt.apache.org/latest/os/modules/hal/hal_i2c/hal_i2c.html#c.hal_i2c_master_write</p>
<h1 id="heap-memory" class="section-header"><a href="#heap-memory">8 Heap Memory</a></h1>
<p>TODO</p>
<p>Mynewt config</p>
<p>https://github.com/lupyuen/pinetime-rust-mynewt/blob/micropython/apps/my_sensor_app/syscfg.yml</p>
<pre><code class="language-yaml">syscfg.vals:
    OS_MAIN_STACK_SIZE: 2048  #  8 KB. Previously 4096 (16 KB)

    # For Bluetooth LE: Lots of smaller mbufs are required for newtmgr using typical BLE ATT MTU values.
    MSYS_1_BLOCK_COUNT:   22  #  Defaults to 12. Previously 64
    MSYS_1_BLOCK_SIZE:   110  #  Defaults to 292
</code></pre>
<h1 id="semihosting-console" class="section-header"><a href="#semihosting-console">9 Semihosting Console</a></h1>
<p>TODO</p>
<p>printf</p>
<h1 id="bluetooth-driver" class="section-header"><a href="#bluetooth-driver">10 Bluetooth Driver</a></h1>
<p>TODO</p>
<p>UART</p>
<h1 id="task-scheduler" class="section-header"><a href="#task-scheduler">11 Task Scheduler</a></h1>
<p>TODO</p>
<h1 id="vscode-workspace" class="section-header"><a href="#vscode-workspace">12 VSCode Workspace</a></h1>
<p>TODO</p>
<h1 id="debug-with-vscode-and-st-link" class="section-header"><a href="#debug-with-vscode-and-st-link">13 Debug with VSCode and ST-Link</a></h1>
<p>TODO</p>
<h1 id="testing-wasp-os-and-micropython-with-mynewt" class="section-header"><a href="#testing-wasp-os-and-micropython-with-mynewt">14 Testing wasp-os and MicroPython with Mynewt</a></h1>
<p>TODO</p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">&quot;MCUBoot Bootloader for PineTime Smart Watch (nRF52)&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu">&quot;Firmware Update over Bluetooth Low Energy on PineTime Smart Watch&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/spiflash">&quot;Configure Mynewt for SPI Flash on PineTime Smart Watch (nRF52)&quot;</a></em></p>
<p>WASP-OS’s documentation</p>
<p>https://wasp-os.readthedocs.io/en/latest/</p>
<p>Application Writer’s Guide</p>
<p>https://wasp-os.readthedocs.io/en/latest/appguide.html</p>
<p>Wasp-os Reference Manual</p>
<p>https://wasp-os.readthedocs.io/en/latest/wasp.html</p>
<h1 id="further-reading" class="section-header"><a href="#further-reading">15 Further Reading</a></h1>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/README.md">Check out the other PineTime articles</a></p>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>

    
</body>
</html>