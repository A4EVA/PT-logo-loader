<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Wayland and LVGL on PinePhone with Ubuntu Touch</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Wayland and LVGL on PinePhone with Ubuntu Touch" 
    data-rh="true">
<meta property="og:description" 
    content="Learn how we code apps on PinePhone with Wayland EGL, OpenGL ES and LVGL" 
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/wayland-title-small.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Wayland and LVGL on PinePhone with Ubuntu Touch</h1>
    <nav id="TOC"><ul>
<li><a href="#how-x11-works">1 How X11 works</a><ul></ul></li>
<li><a href="#wayland-on-ubuntu-touch">2 Wayland on Ubuntu Touch</a><ul></ul></li>
<li><a href="#render-opengl-graphics-with-wayland">3 Render OpenGL Graphics with Wayland</a><ul></ul></li>
<li><a href="#get-egl-context-from-wayland">4 Get EGL Context from Wayland</a><ul></ul></li>
<li><a href="#build-and-test-wayland-app">5 Build and Test Wayland App</a><ul></ul></li>
<li><a href="#fetch-wayland-interfaces">6 Fetch Wayland Interfaces</a><ul></ul></li>
<li><a href="#render-opengl-bitmap-texture-with-wayland">7 Render OpenGL Bitmap Texture with Wayland</a><ul></ul></li>
<li><a href="#lvgl-toolkit-for-graphical-user-interfaces">8 LVGL Toolkit for Graphical User Interfaces</a><ul></ul></li>
<li><a href="#port-lvgl-to-wayland">9 Port LVGL to Wayland</a><ul></ul></li>
<li><a href="#build-lvgl-on-pinephone-with-ubuntu-touch">10 Build LVGL on PinePhone with Ubuntu Touch</a><ul></ul></li>
<li><a href="#overcome-apparmor-security-on-ubuntu-touch">11 Overcome AppArmor Security on Ubuntu Touch</a><ul></ul></li>
<li><a href="#start-ssh-on-pinephone">12 Start SSH on PinePhone</a><ul></ul></li>
<li><a href="#build-lvgl-on-pinephone">13 Build LVGL on PinePhone</a><ul></ul></li>
<li><a href="#run-lvgl-on-pinephone">14 Run LVGL on PinePhone</a><ul></ul></li>
<li><a href="#build-and-test-pinephone-wayland-apps-on-pinebook-pro">15 Build and Test PinePhone Wayland Apps on Pinebook Pro</a><ul></ul></li>
<li><a href="#wayland-gotchas">16 Wayland Gotchas</a><ul></ul></li>
<li><a href="#what-i-like-about-ubuntu-touch-on-pinephone">17 What I like about Ubuntu Touch on PinePhone</a><ul></ul></li>
<li><a href="#further-reading">18 Further Reading</a><ul></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/wayland-title.jpg" alt="Work-in-progress LVGL GUI Framework ported to Wayland EGL on PinePhone with Ubuntu Touch" /></p>
<p><em>Work-in-progress LVGL GUI Framework ported to Wayland EGL on PinePhone with Ubuntu Touch</em></p>
<p><strong>We ‚ù§Ô∏è ¬† Old Underwear...</strong></p>
<p>They feel comfy, they fit our contours. Nevermind the holes and the old stains ü§¢</p>
<p><strong>X11 is like Old Underwear.</strong> It's been around for 30 years... Yet we still use it inspite of its feature gaps and wonky quirks.</p>
<p><strong>PinePhone on Ubuntu Touch feels like... New Underwear.</strong></p>
<p>It runs Linux but it has none of the legacy X11 code. Because it's optimised for a great mobile experience with <strong>Wayland.</strong></p>
<p>But New Underwear feels uncomfortable. So today we'll learn Wayland and understand how apps are built with Wayland.</p>
<p>Hopefully someday we'll move on to newer, simpler app frameworks (like <a href="https://lvgl.io/">LVGL</a> and Flutter) as we discard our Old Underwear: X11, SDL, GTK, Qt, ...</p>
<p>The source code for this article may be found here...</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lvgl-wayland"><code>github.com/lupyuen/lvgl-wayland</code></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-mir"><code>github.com/lupyuen/pinephone-mir</code></a></p>
</li>
</ul>
<h1 id="how-x11-works" class="section-header"><a href="#how-x11-works">1 How X11 works</a></h1>
<p><a href="https://en.wikipedia.org/wiki/X_Window_System">X11</a> is the Graphical Display Service that runs on most Linux desktops and notebooks.</p>
<p>Let's hunt for the X11 Service on Pinebook Pro...</p>
<p><img src="https://lupyuen.github.io/images/wayland-pinebook.png" alt="X11 Service on Pinebook Pro" /></p>
<p>That's the X11 Service... A <strong>2.2 MB</strong> executable named <strong><code>Xorg</code></strong>. </p>
<p>The X11 Service controls the rendering of Linux apps (as well as the keyboard and mouse input) like this...</p>
<p><img src="https://lupyuen.github.io/images/wayland-x11.png" alt="X11 Architecture" /></p>
<p>(Adapted from <a href="https://wayland.freedesktop.org/architecture.html">&quot;Wayland Architecture&quot;</a>)</p>
<ol>
<li>
<p>At the top we have the Linux programs running on our Linux machine: <strong>Terminal, Editor, Web Browser</strong>.</p>
<p>Each program renders its graphical display and transmits the raw graphics to the X11 Service (via a local TCP socket).</p>
</li>
<li>
<p>X11 Service forwards the rendered graphics to the <a href="https://en.wikipedia.org/wiki/Compositing_window_manager"><strong>Window Manager / Compositor</strong></a>.</p>
<p>The Window Manager / Compositor is provided by the <strong>Desktop Environment</strong>: Xfce, KDE, Gnome, ...</p>
</li>
<li>
<p>The Window Manager / Compositor wraps the rendered graphics into Display Windows and <strong>&quot;decorates&quot;</strong> them with scrollbars, title bar and minimise / maximise / close buttons.</p>
<p>The Window Manager / Compositor then draws the Display Windows into a <strong>Screen Buffer</strong> according to their screen coordinates.</p>
</li>
<li>
<p>The Screen Buffer is rendered to our screen by the X11 Service, talking to the <strong>Linux Display Driver</strong>.</p>
</li>
<li>
<p>Any <strong>keyboard and mouse input</strong> is captured by the X11 Service, and forwarded to the programs.</p>
</li>
</ol>
<p><em>Why is X11 so complex? So many hops?</em></p>
<p>Because X11 was designed for Distributed Computing Systems.</p>
<p>Here's how I used (abused?) X11R4 at <a href="http://srg.cs.illinois.edu/">UIUC Systems Research Group</a> way back in 1990 (30 years ago!)...</p>
<p><img src="https://lupyuen.github.io/images/wayland-uiuc.png" alt="Distributed X11 System" /></p>
<p>Thankfully things are a lot simpler now, lemme explain...</p>
<h1 id="wayland-on-ubuntu-touch" class="section-header"><a href="#wayland-on-ubuntu-touch">2 Wayland on Ubuntu Touch</a></h1>
<p><em>Do we need overlapping or tiled windows on PinePhone?</em></p>
<p><em>Do we need to need to decorate PinePhone windows with a title bar and minimise / maximise / close buttons?</em></p>
<p><em>Do we even need any windows on PinePhone?</em></p>
<p>No! Because each PinePhone app takes control of the entire screen!</p>
<p>PinePhone uses a simpler Graphical Display Service: the <a href="https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)#Wayland_compositors"><strong>Wayland Compositor</strong></a>.</p>
<p>Let's hunt for the Wayland Compositor on PinePhone...</p>
<p><img src="https://lupyuen.github.io/images/wayland-compositor.png" alt="Wayland Compositor on PinePhone" /></p>
<p>That's the Wayland Compositor... A <strong>262 KB</strong> executable named <code>unity-system-compositor</code>. </p>
<p><em>Compare that with the 2.2 MB X11 Server on Pinebook Pro!</em></p>
<p>Here's how the Wayland Compositor controls apps and touchscreen input on PinePhone with Ubuntu Touch...</p>
<p><img src="https://lupyuen.github.io/images/wayland-arch.png" alt="Wayland Architecture" /></p>
<p>(Adapted from <a href="https://wayland.freedesktop.org/architecture.html">&quot;Wayland Architecture&quot;</a> and <a href="https://en.wikipedia.org/wiki/EGL_(API)">&quot;EGL API&quot;</a>)</p>
<ol>
<li>
<p>At the top we have the apps running on our phone: <strong>Terminal, Editor, Web Browser</strong>.</p>
<p>Since each app runs fullscreen, only the active app will be rendered.</p>
<p>When then app starts, it queries the <strong>Wayland Compositor</strong> for the graphical display interfaces available. (They talk via a <a href="https://en.wikipedia.org/wiki/Unix_file_types#Socket">Linux socket file</a>: <code>/run/user/32011/wayland-0</code>)</p>
</li>
<li>
<p>Wayland Compositor returns the <a href="https://en.wikipedia.org/wiki/EGL_(API)"><strong>EGL Interface</strong></a> to the app.</p>
</li>
<li>
<p>App calls the EGL Interface to <a href="https://en.wikipedia.org/wiki/OpenGL"><strong>render OpenGL graphics</strong></a> directly to the <strong>Linux Display Driver</strong>.</p>
</li>
<li>
<p>Linux Display Driver forwards the OpenGL rendering commands to the <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit"><strong>GPU to update the screen</strong></a>.</p>
</li>
<li>
<p>Any <strong>touchscreen input</strong> is captured by the Wayland Compositor, and forwarded to the active app.</p>
</li>
</ol>
<p>Wayland looks so much simpler and faster than X11!</p>
<p><em>Wayland is designed for OpenGL and GPUs?</em></p>
<p>Yes! And I lied about Wayland being New Underwear... Wayland is not really that New!</p>
<p>Wayland was first released in 2008 (<a href="https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)">11 years ago</a>)... Yet it was designed around OpenGL and GPUs, the same tech that powers our beautiful games today. (<a href="https://youtu.be/DNBk9hnPkTY">And websites too</a>)</p>
<p>Read on to learn how to render our own OpenGL graphics with Wayland and Ubuntu Touch on PinePhone...</p>
<p><img src="https://lupyuen.github.io/images/wayland-egl.jpg" alt="Rendering a yellow rectangle with Wayland and OpenGL on PinePhone" /></p>
<p><em>Rendering a yellow rectangle with Wayland and OpenGL on PinePhone</em></p>
<h1 id="render-opengl-graphics-with-wayland" class="section-header"><a href="#render-opengl-graphics-with-wayland">3 Render OpenGL Graphics with Wayland</a></h1>
<p>Here's the function that calls OpenGL to render the yellow box above: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L44-L60"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Render the OpenGL ES2 display
static void render_display() {
    //  Fill the rectangular region with yellow
    glClearColor(
        1.0,  //  Red
        1.0,  //  Green
        0.0,  //  Blue
        1.0   //  Alpha
    );
    glClear(GL_COLOR_BUFFER_BIT);

    // Render now
    glFlush();
}
</code></pre>
<p><code>render_display()</code> looks exactly like normal OpenGL, and it works on PinePhone with Wayland! (Thanks to Ubuntu Touch)</p>
<p>Two things to note...</p>
<ol>
<li>
<p>PinePhone supports a popular subset of OpenGL, known as <a href="https://en.wikipedia.org/wiki/OpenGL_ES"><strong>OpenGL for Embedded Systems</strong></a> Version 2.0.</p>
<p>OpenGL ES is optimised for Embedded Devices. It's used by many mobile and console games today.</p>
</li>
<li>
<p>To render OpenGL ES graphics, we need to get the <strong>OpenGL ES Context</strong> and <strong>Window Surface</strong> from Wayland</p>
</li>
</ol>
<p>Before calling <code>render_display()</code>, we fetch the OpenGL Window Surface from Wayland like so: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L167-L189"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Dimensions of the OpenGL region to be rendered
static int WIDTH  = 480;
static int HEIGHT = 360;

static struct wl_egl_window *egl_window;  //  Wayland EGL Window
static EGLSurface egl_surface;            //  EGL Surface

//  Create the EGL Window and render OpenGL graphics
static void create_window(void) {
    //  Create an EGL Window from a Wayland Surface 
    egl_window = wl_egl_window_create(surface, WIDTH, HEIGHT);
    assert(egl_window != EGL_NO_SURFACE);  //  Failed to create OpenGL Window

    //  Create an OpenGL Window Surface for rendering
    egl_surface = eglCreateWindowSurface(egl_display, egl_conf,
        egl_window, NULL);
    assert(egl_surface != NULL);  //  Failed to create OpenGL Window Surface

    //  Set the current rendering surface
    EGLBoolean madeCurrent = eglMakeCurrent(egl_display, egl_surface,
        egl_surface, egl_context);
    assert(madeCurrent);  //  Failed to set rendering surface

    //  Render the display
    render_display();

    //  Swap the display buffers to make the display visible
    EGLBoolean swappedBuffers = eglSwapBuffers(egl_display, egl_surface);
    assert(swappedBuffers);  //  Failed to swap display buffers
}
</code></pre>
<p>Functions named <code>wl_egl_...</code> are provided by the Wayland EGL Interface.  Functions named <code>egl...</code> come from the cross-platform <a href="https://docs.mesa3d.org/egl.html#:%7E:text=The%20main%20library%20(%20libEGL%20)%20is,directly%20dispatched%20to%20the%20drivers.">Mesa 3D Graphics Library</a>.</p>
<p><em>EGL vs OpenGL... What's the difference?</em></p>
<p>In Wayland, EGL is the Enabler for OpenGL. </p>
<p>Wayland only understands EGL and it will gladly hand us EGL objects... But it's up to us to transform EGL into OpenGL for rendering.</p>
<p>Thus in the code above, we take a Wayland Surface <code>surface</code> and transform it into an EGL Window <code>egl_window</code>...</p>
<pre><code class="language-c">//  Create an EGL Window from a Wayland Surface 
egl_window = wl_egl_window_create(surface, WIDTH, HEIGHT);
</code></pre>
<p>Then we create an OpenGL Window Surface <code>egl_surface</code> from that EGL Window...</p>
<pre><code class="language-c">//  Create an OpenGL Window Surface for rendering
egl_surface = eglCreateWindowSurface(egl_display, egl_conf,
    egl_window, NULL);
</code></pre>
<p>And we begin the OpenGL rendering...</p>
<pre><code class="language-c">//  Set the current rendering surface
eglMakeCurrent(egl_display, egl_surface,
    egl_surface, egl_context);

//  Render the display
render_display();

//  Swap the display buffers to make the display visible
eglSwapBuffers(egl_display, egl_surface);
</code></pre>
<p>Here's how we create a Wayland Region for OpenGL rendering: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L103-L112"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">static struct wl_region *region;  //  Wayland Region

//  Create the Wayland Region for rendering OpenGL graphics
static void create_opaque_region(void) {
    //  Create a Wayland Region
    region = wl_compositor_create_region(compositor);
    assert(region != NULL);  //  Failed to create EGL Region

    //  Set the dimensions of the Wayland Region
    wl_region_add(region, 0, 0, WIDTH, HEIGHT);

    //  Add the Region to the Wayland Surface
    wl_surface_set_opaque_region(surface, region);
}
</code></pre>
<p>To learn more about EGL, check out <a href="https://jan.newmarch.name/Wayland/EGL/">&quot;Programming Wayland Clients&quot;</a></p>
<p>The Wayland EGL code in this article was adapted from that document.</p>
<h1 id="get-egl-context-from-wayland" class="section-header"><a href="#get-egl-context-from-wayland">4 Get EGL Context from Wayland</a></h1>
<p>Earlier in <code>create_window()</code> we called an <strong>EGL Context</strong> <code>egl_context</code> to render OpenGL graphics.</p>
<p>Here's how we get the EGL Context: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L113-L165"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Wayland EGL Interfaces for OpenGL Rendering
static EGLDisplay egl_display;  //  EGL Display
static EGLConfig  egl_conf;     //  EGL Configuration
static EGLContext egl_context;  //  EGL Context

//  Create the EGL Context for rendering OpenGL graphics
static void init_egl(void) {
    //  Attributes for our EGL Display
    EGLint config_attribs[] = {
        EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
        EGL_RED_SIZE,        8,
        EGL_GREEN_SIZE,      8,
        EGL_BLUE_SIZE,       8,
        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
        EGL_NONE
    };
    static const EGLint context_attribs[] = {
        EGL_CONTEXT_CLIENT_VERSION, 2,
        EGL_NONE
    };

    //  Get the EGL Display
    egl_display = eglGetDisplay((EGLNativeDisplayType) display);
    assert(egl_display != EGL_NO_DISPLAY);  //  Failed to get EGL Display

    //  Init the EGL Display
    EGLint major, minor;
    EGLBoolean egl_init = eglInitialize(egl_display, &amp;major, &amp;minor);
    assert(egl_init);  //  Failed to init EGL Display

    //  Get the EGL Configurations
    EGLint count, n;
    eglGetConfigs(egl_display, NULL, 0, &amp;count);
    EGLConfig *configs = calloc(count, sizeof *configs);
    eglChooseConfig(egl_display, config_attribs,
        configs, count, &amp;n);

    //  Choose the first EGL Configuration
    for (int i = 0; i &lt; n; i++) {
        EGLint size;
        eglGetConfigAttrib(egl_display, configs[i], EGL_BUFFER_SIZE, &amp;size);
        eglGetConfigAttrib(egl_display, configs[i], EGL_RED_SIZE, &amp;size);
        egl_conf = configs[i];
        break;
    }
    assert(egl_conf != NULL);  //  Failed to get EGL Configuration

    //  Create the EGL Context based on the EGL Display and Configuration
    egl_context = eglCreateContext(egl_display, egl_conf,
        EGL_NO_CONTEXT, context_attribs);
    assert(egl_context != NULL);  //  Failed to create EGL Context
}
</code></pre>
<p><a href="https://jan.newmarch.name/Wayland/EGL/">More about EGL</a></p>
<p>The above code in <code>init_egl()</code> creates the EGL Context. </p>
<p>We call <code>init_egl()</code> in our Main Function like so: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L64-L98"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Wayland Interfaces
static struct wl_surface       *surface;       //  Wayland Surface
static struct wl_shell_surface *shell_surface; //  Wayland Shell Surface

/// Connect to Wayland Compositor and render OpenGL graphics
int main(int argc, char **argv) {
    //  Get interfaces for Wayland Compositor and Wayland Shell
    get_server_references();
    assert(display != NULL);     //  Failed to get Wayland Display
    assert(compositor != NULL);  //  Failed to get Wayland Compositor
    assert(shell != NULL);       //  Failed to get Wayland Shell

    //  Create a Wayland Surface for rendering our app
    surface = wl_compositor_create_surface(compositor);
    assert(surface != NULL);  //  Failed to create Wayland Surface

    //  Get the Wayland Shell Surface for rendering our app window
    shell_surface = wl_shell_get_shell_surface(shell, surface);
    assert(shell_surface != NULL);

    //  Set the Shell Surface as top level
    wl_shell_surface_set_toplevel(shell_surface);

    //  Create the Wayland Region for rendering OpenGL graphics
    create_opaque_region();

    //  Create the EGL Context for rendering OpenGL graphics
    init_egl();

    //  Create the EGL Window and render OpenGL graphics
    create_window();

    //  Handle all Wayland Events in the Event Loop
    while (wl_display_dispatch(display) != -1) {}

    //  Disconnect from the Wayland Display
    wl_display_disconnect(display);
    return 0;
}
</code></pre>
<p>The <code>main()</code> function in all Wayland apps follow the same steps...</p>
<ol>
<li>
<p>Fetch the <strong>Wayland Compositor</strong> and <strong>Wayland Shell</strong> from the <strong>Wayland Registry</strong>...</p>
<pre><code class="language-c">//  Get interfaces for Wayland Compositor and Wayland Shell
get_server_references();
</code></pre>
<p>We'll talk about <code>get_server_references()</code> and the Wayland Registry in a while.</p>
</li>
<li>
<p>Every Wayland App needs a <strong>Wayland Surface</strong> (screen buffer) for displaying the app...</p>
<pre><code class="language-c">//  Create a Wayland Surface for rendering our app
surface = wl_compositor_create_surface(compositor);
</code></pre>
</li>
<li>
<p>Create a <strong>Wayland Shell Surface</strong> (app window) for rendering our app...</p>
<pre><code class="language-c">//  Get the Wayland Shell Surface for rendering our app window
shell_surface = wl_shell_get_shell_surface(shell, surface);
</code></pre>
</li>
<li>
<p>Set the Shell Surface as the <strong>Top Level</strong> window for our app...</p>
<pre><code class="language-c">//  Set the Shell Surface as top level
wl_shell_surface_set_toplevel(shell_surface);
</code></pre>
</li>
<li>
<p>This part is specific to OpenGL apps...</p>
<p>Earlier we have seen <code>create_opaque_region()</code>, <code>init_egl()</code> and <code>create_window()</code>. We call them to create the Wayland Region, EGL Context and EGL Window, and to render the OpenGL graphics.</p>
<pre><code class="language-c">//  Create the Wayland Region for rendering OpenGL graphics
create_opaque_region();
//  Create the EGL Context for rendering OpenGL graphics
init_egl();
//  Create the EGL Window and render OpenGL graphics
create_window();
</code></pre>
</li>
<li>
<p>Every Wayland App needs an <strong>Event Loop</strong> for handling Wayland Events...</p>
<pre><code class="language-c">//  Handle all Wayland Events in the Event Loop
while (wl_display_dispatch(display) != -1) {}
</code></pre>
</li>
<li>
<p>When our app terminates, we disconnect the Wayland Display...</p>
<pre><code class="language-c">//  Disconnect from the Wayland Display
wl_display_disconnect(display);
</code></pre>
</li>
</ol>
<p>Now let's build and test the app on our Linux development machine. (We'll run it on PinePhone later)</p>
<h1 id="build-and-test-wayland-app" class="section-header"><a href="#build-and-test-wayland-app">5 Build and Test Wayland App</a></h1>
<p>Now that we have created a <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c">simple Wayland app</a> that renders OpenGL graphics... Let's build it!</p>
<p>Building a Wayland app is refreshingly simple (if you're used to GDK, Qt and SDL).</p>
<p>Here'a how we build the Wayland app in <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c"><code>egl.c</code></a> on a Linux machine (that has Wayland, MESA EGL and OpenGL ES2 libraries installed)...</p>
<pre><code class="language-bash"># Build the Wayland EGL app
gcc \
    -g \
    -o egl \
    egl.c \
    -Wl,-Map=egl.map \
    -L/usr/lib/aarch64-linux-gnu/mesa-egl \
    -lwayland-client \
    -lwayland-server \
    -lwayland-egl \
    -lEGL \
    -lGLESv2
</code></pre>
<p>This produces the executable app <code>egl</code>. Run the <code>egl</code> app on our Linux machine like so...</p>
<pre><code class="language-bash"># Install Weston Wayland Compositor...
# For Arch Linux and Manjaro:
sudo pacman -S weston

# For Other Distros:
# Check https://github.com/wayland-project/weston

# Start the Weston Wayland Compositor on our computer with the PinePhone screen dimensions
weston --width=720 --height=1398 &amp;

# Run the Wayland EGL app
./egl
</code></pre>
<p>This uses the <a href="https://github.com/wayland-project/weston"><strong>Weston Compositor</strong></a>, the reference implementation of the Wayland Compositor that runs on X11.</p>
<p>We'll see this Inception-like window within a window...</p>
<p><img src="https://lupyuen.github.io/images/wayland-westonegl.png" alt="EGL App running with Wayland Weston Compositor on Pinebook Pro" /></p>
<p>We learn in a while how to build and run the app on PinePhone.</p>
<h1 id="fetch-wayland-interfaces" class="section-header"><a href="#fetch-wayland-interfaces">6 Fetch Wayland Interfaces</a></h1>
<p>Earlier we used the Wayland Compositor and the Wayland Shell in our app...</p>
<ol>
<li>
<p><strong>Wayland Compositor</strong> (<code>compositor</code>): Manages the screen buffer used by apps</p>
</li>
<li>
<p><strong>Wayland Shell</strong> (<code>shell</code>): Manages the app windows</p>
</li>
</ol>
<p>Here's how we fetch the two interfaces from Wayland: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L194-L251"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Wayland Interfaces
static struct wl_display       *display;       //  Wayland Display
static struct wl_compositor    *compositor;    //  Wayland Compositor
static struct wl_shell         *shell;         //  Wayland Shell

/// Connect to Wayland Service and fetch the interfaces for Wayland Compositor and Wayland Shell
static void get_server_references(void) {
    //  Connect to the Wayland Service
    display = wl_display_connect(NULL);
    if (display == NULL) {
        fprintf(stderr, &quot;Failed to connect to display\n&quot;);
        exit(1);
    }

    //  Get the Wayland Registry
    struct wl_registry *registry = wl_display_get_registry(display);
    assert(registry != NULL);  //  Failed to get Wayland Registry

    //  Add Registry Callbacks to handle interfaces returned by Wayland Service
    wl_registry_add_listener(registry, &amp;registry_listener, NULL);

    //  Wait for Registry Callbacks to fetch Wayland Interfaces
    wl_display_dispatch(display);
    wl_display_roundtrip(display);

    //  We should have received interfaces for Wayland Compositor and Wayland Shell
    assert(compositor != NULL);  //  Failed to get Wayland Compositor
    assert(shell != NULL);       //  Failed to get Wayland Shell
}
</code></pre>
<p>What happens inside <code>get_server_references()</code>?</p>
<ol>
<li>
<p>The Wayland Compositor runs as a Linux Service that listens on a <a href="https://en.wikipedia.org/wiki/Unix_file_types#Socket">Linux Socket File</a>: <code>/run/user/32011/wayland-0</code> for PinePhone on Ubuntu Touch.</p>
<p>We connect to the <strong>Wayland Service</strong> like so...</p>
<pre><code class="language-c">//  Connect to the Wayland Service
display = wl_display_connect(NULL);
</code></pre>
<p>Remember that all functions named <code>wl_...</code> come from the Wayland Library.</p>
</li>
<li>
<p>To work with the Wayland Service, we fetch the Interfaces for the Wayland Compositor and Wayland Shell.</p>
<p><strong>Wayland Interfaces</strong> are defined in the <strong>Wayland Registry</strong>...</p>
<pre><code class="language-c">//  Get the Wayland Registry
struct wl_registry *registry = wl_display_get_registry(display);
</code></pre>
</li>
<li>
<p>To fetch the Compositor and Shell from the Wayland Registry, we add a <strong>Registry Listener</strong> (more about this later)...</p>
<pre><code class="language-c">//  Add Registry Callbacks to handle interfaces returned by Wayland Service
wl_registry_add_listener(registry, &amp;registry_listener, NULL);
</code></pre>
</li>
<li>
<p>Now we <strong>dispatch the Registry Listener request</strong> to the Wayland Service. (Remember that the Wayland Service operates on Linux Socket Messages)</p>
<pre><code class="language-c">//  Wait for Registry Callbacks to fetch Wayland Interfaces
wl_display_dispatch(display);
wl_display_roundtrip(display);
</code></pre>
</li>
</ol>
<p>And we'll get the <code>compositor</code> and <code>shell</code> objects populated from the Wayland Registry!</p>
<p>If you're curious, the Registry Listener works like this: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L194-L251"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Callbacks for interfaces returned by Wayland Service
static const struct wl_registry_listener registry_listener = {
    global_registry_handler,
    global_registry_remover
};

/// Callback for interfaces returned by Wayland Service
static void global_registry_handler(void *data, struct wl_registry *registry, uint32_t id,
    const char *interface, uint32_t version) {
    printf(&quot;Got interface %s id %d\n&quot;, interface, id);

    if (strcmp(interface, &quot;wl_compositor&quot;) == 0) {
        //  Bind to Wayland Compositor Interface
        compositor = wl_registry_bind(registry, id,
            &amp;wl_compositor_interface,   //  Interface Type
            1);                         //  Interface Version
    } else if (strcmp(interface, &quot;wl_shell&quot;) == 0){
        //  Bind to Wayland Shell Interface
        shell = wl_registry_bind(registry, id,
            &amp;wl_shell_interface,        //  Interface Type
            1);                         //  Interface Version
    }
}
</code></pre>
<p><code>global_registry_handler()</code> is the Callback Function that will be triggered for every interface in the Wayland Registry. </p>
<p>The Wayland Service for Ubuntu Touch <code>unity-system-compositor</code> returns a whole bunch of interesting Wayland Interfaces (like <code>qt_windowmanager</code>). </p>
<p>But today we'll bind to the Compositor Interface named <code>wl_compositor</code> and Shell Interface named <code>wl_shell</code>.</p>
<p>And that's how we render a yellow rectangle with Wayland and OpenGL!</p>
<p>Let's move on to something more interesting: Rendering a simple bitmap texture...</p>
<p><img src="https://lupyuen.github.io/images/wayland-egl2.jpg" alt="Rendering a simple bitmap texture with Wayland and OpenGL on PinePhone" /></p>
<p><em>Rendering a simple bitmap texture with Wayland and OpenGL on PinePhone</em></p>
<h1 id="render-opengl-bitmap-texture-with-wayland" class="section-header"><a href="#render-opengl-bitmap-texture-with-wayland">7 Render OpenGL Bitmap Texture with Wayland</a></h1>
<p>The four boxes we see above are rendered from a magnified <strong>2-pixel by 2-pixel bitmap</strong>: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/texture.c#L30-L64"><code>pinephone-mir/texture.c</code></a></p>
<pre><code class="language-c">// 2x2 Image, 3 bytes per pixel (R, G, B)
GLubyte pixels[4 * 3] = {
    255, 0, 0,  // Red
    0, 255, 0,  // Green
    0, 0, 255,  // Blue
    255, 255, 0 // Yellow
};
</code></pre>
<p>We render the bitmap by creating an <strong>OpenGL Texture</strong>: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/texture.c#L30-L64"><code>pinephone-mir/texture.c</code></a></p>
<pre><code class="language-c">// Create a simple 2x2 texture image with four different colors
GLuint CreateSimpleTexture2D() {
    // Texture object handle
    GLuint textureId;

    // 2x2 Image, 3 bytes per pixel (R, G, B)
    GLubyte pixels[4 * 3] = {
        255, 0, 0,  // Red
        0, 255, 0,  // Green
        0, 0, 255,  // Blue
        255, 255, 0 // Yellow
    };

    // Use tightly packed data
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    // Generate a texture object
    glGenTextures(1, &amp;textureId);

    // Bind the texture object
    glBindTexture(GL_TEXTURE_2D, textureId);

    // Load the texture
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 2, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);

    // Set the filtering mode
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    return textureId;
}
</code></pre>
<p>(Not the most efficient way to render a bitmap... But let's try this and test drive PinePhone's GPU!)</p>
<p>This is the usual way we create an OpenGL Texture, as explained in <a href="http://www.opengles-book.com/">&quot;OpenGL¬Æ ES 3.0 Programming Guide&quot;</a>.</p>
<p>Here comes the tricky part... Before rendering the OpenGL Texture, we need to program the <strong>GPU Shaders</strong> on PinePhone with a C-like language: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/texture.c#L66-L93"><code>pinephone-mir/texture.c</code></a></p>
<pre><code class="language-c">// Initialize the shader and program object
int Init(ESContext *esContext) {
    esContext-&gt;userData = malloc(sizeof(UserData));
    UserData *userData = esContext-&gt;userData;
    GLbyte vShaderStr[] =
        &quot;attribute vec4 a_position;   \n&quot;
        &quot;attribute vec2 a_texCoord;   \n&quot;
        &quot;varying vec2 v_texCoord;     \n&quot;
        &quot;void main()                  \n&quot;
        &quot;{                            \n&quot;
        &quot;   gl_Position = a_position; \n&quot;
        &quot;   v_texCoord = a_texCoord;  \n&quot;
        &quot;}                            \n&quot;;

    GLbyte fShaderStr[] =
        &quot;precision mediump float;                            \n&quot;
        &quot;varying vec2 v_texCoord;                            \n&quot;
        &quot;uniform sampler2D s_texture;                        \n&quot;
        &quot;void main()                                         \n&quot;
        &quot;{                                                   \n&quot;
        &quot;  gl_FragColor = texture2D( s_texture, v_texCoord );\n&quot;
        &quot;}                                                   \n&quot;;

    // Load the shaders and get a linked program object
    userData-&gt;programObject = esLoadProgram(vShaderStr, fShaderStr);
    ...
</code></pre>
<p>(Yep a C program within a C program... Inception!)</p>
<p><code>esLoadProgram()</code> is defined in <a href="https://github.com/lupyuen/pinephone-mir/blob/master/shader.c"><code>pinephone-mir/shader.c</code></a></p>
<p>We're now talking to PinePhone's GPU, which is so low-level that it understand only Triangles, not Rectangles.</p>
<p>Hence to render the OpenGL Texture, we map the Rectangular Texture onto two Triangles and render them: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/texture.c#L109-L130"><code>pinephone-mir/texture.c</code></a></p>
<pre><code class="language-c">// Draw a triangle using the shader pair created in Init()
void Draw(ESContext *esContext) {
    GLfloat vVertices[] = {
        -0.5f,   0.5f,  0.0f,  // Position 0
         0.0f,   0.0f,         // TexCoord 0
        -0.5f,  -0.5f,  0.0f,  // Position 1
         0.0f,   1.0f,         // TexCoord 1
         0.5f,  -0.5f,  0.0f,  // Position 2
         1.0f,   1.0f,         // TexCoord 2
         0.5f,   0.5f,  0.0f,  // Position 3
         1.0f,   0.0f          // TexCoord 3
    };
    GLushort indices[] = {
        0, 1, 2,  //  First Triangle
        0, 2, 3   //  Second Triangle
    };
    ...
    //  Draw the 6 vertices as 2 triangles
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices);
}
</code></pre>
<p>(Yes the math is starting to hurt... But that's the end of it!)</p>
<p>Finally we connect the above code to render the four colour boxes on PinePhone, thanks to Wayland and OpenGL: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl2.c#L51-L67">pinephone-mir/egl2.c</a></p>
<pre><code class="language-c">/// Render the OpenGL ES2 display
static void render_display() {
    //  Create the texture context
    static ESContext esContext;
    esInitContext ( &amp;esContext );
    esContext.width  = WIDTH;
    esContext.height = HEIGHT;

    //  Draw the texture
    Init(&amp;esContext);
    Draw(&amp;esContext);

    //  Render now
    glFlush();
}
</code></pre>
<p>And that's <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl2.c">our Wayland App</a> that renders a simple OpenGL Bitmap Texture!</p>
<p>The OpenGL Texture code in this article was adapted from <a href="https://github.com/danginsburg/opengles-book-samples">&quot;OpenGL¬Æ ES 2.0 Programming Guide&quot;</a></p>
<p>Let's head on towards greatness and something really useful: Graphical User Interfaces...</p>
<p><img src="https://lupyuen.github.io/images/wayland-button.jpg" alt="Button rendered with LVGL and Wayland on PinePhone" /></p>
<p><em>Button rendered with LVGL and Wayland on PinePhone</em></p>
<h1 id="lvgl-toolkit-for-graphical-user-interfaces" class="section-header"><a href="#lvgl-toolkit-for-graphical-user-interfaces">8 LVGL Toolkit for Graphical User Interfaces</a></h1>
<p>Now that we can render bitmaps on PinePhone, let's think...</p>
<p><em>How would we render a simple Graphical User Interface (GUI) on PinePhone, like the button above?</em></p>
<p>Why don't we use a simple GUI Toolkit like <a href="https://lvgl.io/"><strong>LVGL</strong></a>? (Formerly LittleVGL)</p>
<p>Here's how we call the LVGL library to render that button: <a href="https://github.com/lupyuen/lvgl-wayland/blob/master/wayland/lvgl.c#L54-L64"><code>lvgl-wayland/wayland/lvgl.c</code></a></p>
<pre><code class="language-c">#include &quot;../lvgl.h&quot;

/// Render a Button Widget and a Label Widget
static void render_widgets(void) {
    lv_obj_t * btn = lv_btn_create(lv_scr_act(), NULL);     //  Add a button the current screen
    lv_obj_set_pos(btn, 10, 10);                            //  Set its position
    lv_obj_set_size(btn, 120, 50);                          //  Set its size

    lv_obj_t * label = lv_label_create(btn, NULL);          //  Add a label to the button
    lv_label_set_text(label, &quot;Button&quot;);                     //  Set the labels text
}
</code></pre>
<p><em>Easy peasy!</em></p>
<p>LVGL is a simple C toolkit designed for Embedded Devices, so it needs <strong>very little memory and processing power</strong>.  LVGL is <strong>self-contained</strong>... Fonts and icons are bundled into the LVGL library.</p>
<p>It's used on <a href="https://github.com/JF002/Pinetime"><strong>PineTime Smart Watch</strong></a> to render watch faces.</p>
<p><em>LVGL doesn't run on Wayland yet... But we'll fix that!</em></p>
<p>Remember how we rendered a simple 2-pixel by 2-pixel bitmap by creating an OpenGL Texture with <code>CreateSimpleTexture2D()</code>?</p>
<p>Let's extend that bitmap to cover the entire PinePhone screen: 720 pixels by 1398 pixels.</p>
<p>And we create the OpenGL Texture for the entire PinePhone screen like so: <a href="https://github.com/lupyuen/lvgl-wayland/blob/master/wayland/texture.c#L38-L72"><code>lvgl-wayland/wayland/texture.c</code></a></p>
<pre><code class="language-c">///  PinePhone Screen Resolution, defined in lv_conf.h
#define LV_HOR_RES_MAX          (720)
#define LV_VER_RES_MAX          (1398)
#define LV_SCALE_RES            1

///  Screen buffer 
#define BYTES_PER_PIXEL 3
GLubyte pixels[LV_HOR_RES_MAX * LV_VER_RES_MAX * BYTES_PER_PIXEL];

/// Create an OpenGL Texture for the screen buffer
GLuint CreateTexture(void) {
    GLuint texId;
    glGenTextures ( 1, &amp;texId );
    glBindTexture ( GL_TEXTURE_2D, texId );

    glTexImage2D (
        GL_TEXTURE_2D, 
        0,  //  Level
        GL_RGB, 
        LV_HOR_RES_MAX,  //  Width
        LV_VER_RES_MAX,  //  Height 
        0,  //  Format 
        GL_RGB, 
        GL_UNSIGNED_BYTE, 
        pixels 
    );
    glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
    glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
    glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
    glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
    return texId;
}
</code></pre>
<p><code>pixels</code> is the screen buffer that will contain the pixels for our rendered UI controls, like our button.</p>
<p>We'll tell LVGL to render into <code>pixels</code> like so: <a href="https://github.com/lupyuen/lvgl-wayland/blob/master/wayland/texture.c#L38-L72"><code>lvgl-wayland/wayland/texture.c</code></a></p>
<pre><code class="language-c">/// Set the colour of a pixel in the screen buffer
void put_px(uint16_t x, uint16_t y, uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    assert(x &gt;= 0); assert(x &lt; LV_HOR_RES_MAX);
    assert(y &gt;= 0); assert(y &lt; LV_VER_RES_MAX);
    int i = (y * LV_HOR_RES_MAX * BYTES_PER_PIXEL) + (x * BYTES_PER_PIXEL);
    pixels[i++] = r;  //  Red
    pixels[i++] = g;  //  Green
    pixels[i++] = b;  //  Blue
}
</code></pre>
<p>(Simplistic, not efficient though)</p>
<p>We'll render the OpenGL Texture the same way as before: <a href="https://github.com/lupyuen/lvgl-wayland/blob/master/wayland/lvgl.c#L65-L93"><code>lvgl-wayland/wayland/lvgl.c</code></a></p>
<pre><code class="language-c">/// Render the OpenGL ES2 display
static void render_display() {
    //  This part is new...

    //  Init the LVGL display
    lv_init();
    lv_port_disp_init();

    //  Create the LVGL widgets: Button and label
    render_widgets();

    //  Render the LVGL widgets
    lv_task_handler();

    //  This part is the same as before...

    //  Create the texture context
    static ESContext esContext;
    esInitContext ( &amp;esContext );
    esContext.width  = WIDTH;
    esContext.height = HEIGHT;

    //   Draw the texture
    Init(&amp;esContext);
    Draw(&amp;esContext);

    //  Render now
    glFlush();
}
</code></pre>
<p>But now we have injected the calls to the LVGL library...</p>
<ol>
<li>
<p><a href="https://docs.lvgl.io/latest/en/html/widgets/obj.html?highlight=lv_init#_CPPv47lv_initv"><strong><code>lv_init()</code></strong></a>: Initialise the LVGL library</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lvgl-wayland/blob/72b0273d6c609ecb51142ee400f545116ca0ecd9/wayland/lv_port_disp.c#L48-L126"><strong><code>lv_port_disp_init()</code></strong></a>: Initialise our display</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lvgl-wayland/blob/master/wayland/lvgl.c#L54-L64"><strong><code>render_widgets()</code></strong></a>: Calls the LVGL library to create two UI controls: a Button and a Label</p>
</li>
<li>
<p><a href="https://docs.lvgl.io/latest/en/html/porting/task-handler.html?highlight=lv_task_handler"><strong><code>lv_task_handler()</code></strong></a>: Let LVGL render the UI controls into our screen buffer</p>
</li>
</ol>
<p>Now let's tweak the LVGL library to render UI controls into our screen buffer <code>pixels</code></p>
<h1 id="port-lvgl-to-wayland" class="section-header"><a href="#port-lvgl-to-wayland">9 Port LVGL to Wayland</a></h1>
<p>Porting LVGL to Wayland and Ubuntu Touch is straightforward.</p>
<p>According to the <a href="https://docs.lvgl.io/latest/en/html/porting/display.html">LVGL Porting Doc</a>, we need to code a Flush Callback Function <code>disp_flush()</code> that will be called by LVGL to render UI controls to the screen buffer.</p>
<p>Here's our implementation for Wayland: <a href="https://github.com/lupyuen/lvgl-wayland/blob/master/wayland/lv_port_disp.c#L142-L167"><code>lvgl-wayland/wayland/lv_port_disp.c</code></a></p>
<pre><code class="language-c">//  Flush the content of the internal buffer to the specific area on the display
//  You can use DMA or any hardware acceleration to do this operation in the background but
//  'lv_disp_flush_ready()' has to be called when finished.
static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p) {
    //  The most simple case (but also the slowest) to put all pixels to the screen one-by-one
    for(int32_t y = area-&gt;y1; y &lt;= area-&gt;y2; y++) {
        for(int32_t x = area-&gt;x1; x &lt;= area-&gt;x2; x++) {
            //  Put a pixel to the screen buffer
            put_px(x, y, 
                color_p-&gt;ch.red, 
                color_p-&gt;ch.green, 
                color_p-&gt;ch.blue, 
                0xff);
            color_p++;
        }
    }
    //  Inform the graphics library that we are ready with the flushing
    lv_disp_flush_ready(disp_drv);
}
</code></pre>
<p>We've seen earlier that <code>put_px()</code> draws pixels in the simplest way possible.  Eventually we should use PinePhone's GPU for rendering LVGL controls, by implementing the <a href="https://docs.lvgl.io/latest/en/html/porting/display.html#display-driver">LVGL GPU Callbacks</a>.</p>
<p>Light and Dark Themes are provided by LVGL. To select the default theme just edit <a href="https://github.com/lupyuen/lvgl-wayland/blob/master/lv_conf.h#L444-L446"><code>lvgl-wayland/lv_conf.h</code></a></p>
<p>Here's Dark Theme...</p>
<pre><code class="language-c">//  For Dark Theme...
#define LV_THEME_DEFAULT_FLAG LV_THEME_MATERIAL_FLAG_DARK
</code></pre>
<p><img src="https://lupyuen.github.io/images/wayland-dark.jpg" alt="LVGL Dark Theme with Wayland on PinePhone" /></p>
<p>And Light Theme...</p>
<pre><code class="language-c">//  For Light Theme...
#define LV_THEME_DEFAULT_FLAG LV_THEME_MATERIAL_FLAG_LIGHT
</code></pre>
<p><img src="https://lupyuen.github.io/images/wayland-light.jpg" alt="LVGL Light Theme with Wayland on PinePhone" /></p>
<p>The screens above were rendered by updating one line in <a href="https://github.com/lupyuen/lvgl-wayland/blob/master/wayland/lvgl.c#L65-L76"><code>lvgl-wayland/wayland/lvgl.c</code></a>...</p>
<pre><code class="language-c">/// Render the OpenGL ES2 display
static void render_display() {
    //  Init the LVGL display
    lv_init();
    lv_port_disp_init();

    //  Create the LVGL widgets
    lv_demo_widgets();  //  Previously render_widgets()
</code></pre>
<p><em>What about Touch Input in LVGL for Ubuntu Touch?</em></p>
<p>We haven't handled Touch Input yet... Lemme know if you're keen to help!</p>
<p><em>Do we really have to code LVGL Apps for PinePhone in C?</em></p>
<p>Rust is supported too! </p>
<p>We may write LVGL Apps for PinePhone in Rust by calling the <a href="https://github.com/rafaelcaricio/lvgl-rs"><strong><code>lvgl-rs</code> Rust Wrapper for LVGL</strong></a> by <a href="https://github.com/rafaelcaricio"><strong>Rafael Car√≠cio</strong></a>.</p>
<p>(Fun Fact: <code>lvgl-rs</code> was <a href="https://lupyuen.github.io/PineTime-apps/articles/watch_face">originally created</a> for PineTime Smart Watch... Today it's used by <a href="https://twitter.com/rafaelcaricio/status/1271886471260184577?s=20">Rust on PlayStation Portable</a> too!)</p>
<p><img src="https://lupyuen.github.io/images/wayland-size.jpg" alt="Size of LVGL Demo App on PinePhone with Ubuntu Touch" /></p>
<p><em>How small is LVGL on PinePhone with Ubuntu Touch?</em></p>
<p><strong>1.5 MB</strong> for the Light / Dark Theme LVGL Demo App above.</p>
<p>Not that big, considering that the font, icons and debugging symbols are bundled inside.</p>
<p><em>How does LVGL compare with Qt, GTK and SDL on PinePhone with Ubuntu Touch?</em></p>
<p>Qt is the only officially supported App Toolkit on Ubuntu Touch. </p>
<p>GTK and SDL are supposed to work on Wayland... But I couldn't get them to work on Ubuntu Touch. </p>
<p>(Probably because legacy X11 compatibility is missing from Ubuntu Touch, i.e. XWayland)</p>
<p>I applaud the maintainers of X11, Qt, GTK and SDL because every new release needs to support so many legacy features. Kudos!</p>
<p>But what if we could start from scratch, drop the legacy stuff, and build a simpler UI toolkit for Wayland?</p>
<p><em>LVGL is the experiment that we're undertaking today!</em></p>
<h1 id="build-lvgl-on-pinephone-with-ubuntu-touch" class="section-header"><a href="#build-lvgl-on-pinephone-with-ubuntu-touch">10 Build LVGL on PinePhone with Ubuntu Touch</a></h1>
<p>TODO</p>
<h1 id="overcome-apparmor-security-on-ubuntu-touch" class="section-header"><a href="#overcome-apparmor-security-on-ubuntu-touch">11 Overcome AppArmor Security on Ubuntu Touch</a></h1>
<p>TODO</p>
<p>Why AppArmor?</p>
<h1 id="start-ssh-on-pinephone" class="section-header"><a href="#start-ssh-on-pinephone">12 Start SSH on PinePhone</a></h1>
<p>To start SSH on PinePhone, open the Terminal app.</p>
<p>Create a file named <code>a</code>...</p>
<pre><code class="language-bash">nano a
</code></pre>
<p>Type this script into the <code>a</code> file...</p>
<pre><code class="language-bash">#!/bin/sh
# Script to start SSH service and show IP address

# Start SSH service
sudo service ssh start

# Show IP address
ifconfig | \
    grep -v &quot;127.0.0.1&quot; | \
    grep &quot;inet addr:&quot;

# Ping repeatedly to keep WiFi alive
ping google.com
</code></pre>
<p>Save the file and exit <code>nano</code>.</p>
<p>TODO: How to install the script on PinePhone via SD card or Bluetooth</p>
<p>When we're ready do coding on PinePhone, enter this at the command line...</p>
<pre><code class="language-bash">. a 
</code></pre>
<p>(There's a space between &quot;<code>.</code>&quot; and &quot;<code>a</code>&quot;)</p>
<p>The script starts the SSH Service and displays the IP address for PinePhone...</p>
<p><img src="https://lupyuen.github.io/images/wayland-ssh.jpg" alt="Starting SSH Service on PinePhone" /></p>
<p>We'll connect to PinePhone at the IP adddress indicated by <code>inet addr</code>. </p>
<p>Tap on <code>Ctrl-C</code> to stop the <code>ping</code>.</p>
<p>TODO: How to install SSH key on PinePhone via SD card or Bluetooth</p>
<p>When we press PinePhone's power button to switch off PinePhone, we'll see ths amusing message from olden times...</p>
<p><img src="https://lupyuen.github.io/images/wayland-halt.jpg" alt="Powering off PinePhone" /></p>
<h1 id="build-lvgl-on-pinephone" class="section-header"><a href="#build-lvgl-on-pinephone">13 Build LVGL on PinePhone</a></h1>
<p>TODO</p>
<h1 id="run-lvgl-on-pinephone" class="section-header"><a href="#run-lvgl-on-pinephone">14 Run LVGL on PinePhone</a></h1>
<p>TODO</p>
<p>Mir Server Log may be found on PinePhone here...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="op">/</span><span class="ident">home</span><span class="op">/</span><span class="ident">phablet</span><span class="op">/</span>.<span class="ident">cache</span><span class="op">/</span><span class="ident">upstart</span><span class="op">/</span><span class="ident">unity8</span>.<span class="ident">log</span></pre></div>
<p>Copy the log to our machine like this...</p>
<pre><code class="language-bash">scp -i ~/.ssh/pinebook_rsa phablet@192.168.1.10:/home/phablet/.cache/upstart/u
</code></pre>
<p><img src="https://lupyuen.github.io/images/wayland-weston.png" alt="PinePhone Wayland App tested on Pinebook Pro" /></p>
<h1 id="build-and-test-pinephone-wayland-apps-on-pinebook-pro" class="section-header"><a href="#build-and-test-pinephone-wayland-apps-on-pinebook-pro">15 Build and Test PinePhone Wayland Apps on Pinebook Pro</a></h1>
<p>Here's how we can build and test PinePhone Wayland Apps on Pinebook Pro...</p>
<pre><code class="language-bash"># Create a symbolic link for the OpenGL ES2 shared library that will be used for the Wayland build
sudo mkdir -p /usr/lib/aarch64-linux-gnu/mesa-egl/
sudo ln -s /usr/lib/libGLESv2.so /usr/lib/aarch64-linux-gnu/mesa-egl/libGLESv2.so.2

# Build the Wayland executable
make

# Start the Weston Wayland Compositor on Pinebook Pro with the PinePhone screen dimensions
weston --width=720 --height=1398 &amp;

# Run the Wayland executable
wayland/lvgl
</code></pre>
<h1 id="wayland-gotchas" class="section-header"><a href="#wayland-gotchas">16 Wayland Gotchas</a></h1>
<p>TODO</p>
<p>GPU on X11:</p>
<p>https://qoto.org/@lupyuen/104541068127168291</p>
<p>GNOME and GTK on Wayland:</p>
<p>https://mastodon.social/@ebassi/104511735257435944</p>
<p>UBports on Mir:</p>
<p>https://twitter.com/UBports/status/1282935946711904257?s=09</p>
<p>https://twitter.com/UBports/status/1282934927806398464?s=09</p>
<p>https://twitter.com/UBports/status/1282936886311428096?s=09</p>
<p>Wayland on Xfce:</p>
<p>https://twitter.com/XfceNation/status/1284842929895301120?s=09</p>
<p>https://twitter.com/XfceNation/status/1284854254092513285?s=09</p>
<p>Mir / Lomiri / Unity8's complicated history:</p>
<p>https://www.phoronix.com/scan.php?page=news_item&amp;px=Mir-2019-Kicking</p>
<p>https://www.phoronix.com/scan.php?page=news_item&amp;px=Unity-8-Renamed-To-Lomiri</p>
<h1 id="what-i-like-about-ubuntu-touch-on-pinephone" class="section-header"><a href="#what-i-like-about-ubuntu-touch-on-pinephone">17 What I like about Ubuntu Touch on PinePhone</a></h1>
<p>TODO</p>
<p>AppArmor is good, because iOS and Android have similar apps security</p>
<p>Read-only file system is good (system files are read-only by default, user files are read-write). Helps to prevent security holes. (Even PineTime has a read-only Flash ROM)</p>
<p>Why is Qt supported on Ubuntu Touch and not GTK? Because building a Linux mobile app requires mobile-friendly widgets.</p>
<p>I think Qt has more mobile-friendly widgets, even through the internal plumbing is way too complicated.</p>
<p>When I get GTK running on Ubuntu Touch, I will face the same problem with widgets. And I have to make GTK widgets look and feel consistent with Qt / Ubuntu Touch widgets.</p>
<p>Older kernel base in Ubuntu Touch... I don't do kernel hacking much so it doesn't matter to me.</p>
<p>I think for mobiles we only need to support a few common chipsets, so an older kernel is probably fine.</p>
<p>That explains why Raspberry Pi 4 isn't supported by Ubuntu Touch... The hardware is just too new.</p>
<p>The issues I'm struggling with now... Wayland, GTK3, ... are actually really old stuff. Updating the kernel won't help.</p>
<p>Ubuntu Touch is pure Wayland, none of the legacy X11 stuff. Xwayland is not even there (unless you use the Libertine containers ugh).</p>
<p>The pure Wayland environment causes GTK to break, because GTK assumes some minimal X11 support (i.e. Xwayland).</p>
<p>So Ubuntu Touch is not really that bad for PinePhone... It's just painful for building non-Qt apps. üôÇ</p>
<h1 id="further-reading" class="section-header"><a href="#further-reading">18 Further Reading</a></h1>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/bloc">&quot;Flutter State Management with Bloc for PineTime Companion App&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/companion">&quot;Convert Go to Flutter and Dart for PineTime Companion App&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/flutter">&quot;Your First Bluetooth Low Energy App with Flutter&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/gotk3">&quot;Your First GTK App with Go and VSCodium&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">&quot;MCUBoot Bootloader for PineTime Smart Watch (nRF52)&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu">&quot;Firmware Update over Bluetooth Low Energy on PineTime Smart Watch&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfutest">&quot;Wireless Firmware Update In Action on PineTime Smart Watch (nRF52)&quot;</a></em></p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/README.md">Check out the other PineTime articles</a></p>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>

    
</body>
</html>