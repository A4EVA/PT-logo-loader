<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Wayland and LVGL on PinePhone with Ubuntu Touch</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Wayland and LVGL on PinePhone with Ubuntu Touch" 
    data-rh="true">
<meta property="og:description" 
    content="Learn how we code apps on PinePhone with Wayland EGL, OpenGL ES and LVGL" 
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/wayland-title-small.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Wayland and LVGL on PinePhone with Ubuntu Touch</h1>
    <nav id="TOC"><ul>
<li><a href="#how-x11-works">1 How X11 works</a><ul></ul></li>
<li><a href="#wayland-on-ubuntu-touch">2 Wayland on Ubuntu Touch</a><ul></ul></li>
<li><a href="#render-opengl-graphics-with-wayland">3 Render OpenGL Graphics with Wayland</a><ul></ul></li>
<li><a href="#fetch-wayland-interfaces">4 Fetch Wayland Interfaces</a><ul></ul></li>
<li><a href="#render-opengl-texture-with-wayland">5 Render OpenGL Texture with Wayland</a><ul></ul></li>
<li><a href="#port-lvgl-to-wayland">6 Port LVGL to Wayland</a><ul></ul></li>
<li><a href="#overcome-apparmor-security-on-ubuntu-touch">7 Overcome AppArmor Security on Ubuntu Touch</a><ul></ul></li>
<li><a href="#start-ssh-on-pinephone">8 Start SSH on PinePhone</a><ul></ul></li>
<li><a href="#build-lvgl-on-pinephone">9 Build LVGL on PinePhone</a><ul></ul></li>
<li><a href="#run-lvgl-on-pinephone">10 Run LVGL on PinePhone</a><ul></ul></li>
<li><a href="#build-and-test-pinephone-wayland-apps-on-pinebook-pro">11 Build and Test PinePhone Wayland Apps on Pinebook Pro</a><ul></ul></li>
<li><a href="#wayland-gotchas">12 Wayland Gotchas</a><ul></ul></li>
<li><a href="#what-i-like-about-ubuntu-touch-on-pinephone">13 What I like about Ubuntu Touch on PinePhone</a><ul></ul></li>
<li><a href="#further-reading">14 Further Reading</a><ul></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/wayland-title.jpg" alt="Work-in-progress LVGL GUI Framework ported to Wayland EGL on PinePhone with Ubuntu Touch" /></p>
<p><em>Work-in-progress LVGL GUI Framework ported to Wayland EGL on PinePhone with Ubuntu Touch</em></p>
<p><strong>We ‚ù§Ô∏è ¬† Old Underwear...</strong></p>
<p>They feel comfy, they fit our contours. Nevermind the holes and the old stains ü§¢</p>
<p><strong>X11 is like Old Underwear.</strong> It's been around for 30 years... Yet we still use it inspite of its feature gaps and wonky quirks.</p>
<p><strong>PinePhone on Ubuntu Touch feels like... New Underwear.</strong></p>
<p>It runs Linux but it has none of the legacy X11 code. Because it's optimised for a great mobile experience with <strong>Wayland.</strong></p>
<p>But New Underwear feels uncomfortable. So today we'll learn Wayland and understand how apps are built with Wayland.</p>
<p>Hopefully someday we'll move on to newer, simpler app frameworks (like <a href="https://lvgl.io/">LVGL</a> and Flutter) as we discard our Old Underwear: X11, SDL, GTK, Qt, ...</p>
<p>The source code for this article may be found here...</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lvgl-wayland"><code>github.com/lupyuen/lvgl-wayland</code></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-mir"><code>github.com/lupyuen/pinephone-mir</code></a></p>
</li>
</ul>
<h1 id="how-x11-works" class="section-header"><a href="#how-x11-works">1 How X11 works</a></h1>
<p><a href="https://en.wikipedia.org/wiki/X_Window_System">X11</a> is the Graphical Display Service that runs on most Linux desktops and notebooks.</p>
<p>Let's hunt for the X11 Service on Pinebook Pro...</p>
<p><img src="https://lupyuen.github.io/images/wayland-pinebook.png" alt="X11 Service on Pinebook Pro" /></p>
<p>That's the X11 Service... A <strong>2.2 MB</strong> executable named <strong><code>Xorg</code></strong>. </p>
<p>The X11 Service controls the rendering of Linux apps (as well as the keyboard and mouse input) like this...</p>
<p><img src="https://lupyuen.github.io/images/wayland-x11.png" alt="X11 Architecture" /></p>
<p>(Adapted from <a href="https://wayland.freedesktop.org/architecture.html">&quot;Wayland Architecture&quot;</a>)</p>
<ol>
<li>
<p>At the top we have the Linux programs running on our Linux machine: <strong>Terminal, Editor, Web Browser</strong>.</p>
<p>Each program renders its graphical display and transmits the raw graphics to the X11 Service (via a local TCP socket).</p>
</li>
<li>
<p>X11 Service forwards the rendered graphics to the <a href="https://en.wikipedia.org/wiki/Compositing_window_manager"><strong>Window Manager / Compositor</strong></a>.</p>
<p>The Window Manager / Compositor is provided by the <strong>Desktop Environment</strong>: Xfce, KDE, Gnome, ...</p>
</li>
<li>
<p>The Window Manager / Compositor wraps the rendered graphics into Display Windows and <strong>&quot;decorates&quot;</strong> them with scrollbars, title bar and minimise / maximise / close buttons.</p>
<p>The Window Manager / Compositor then draws the Display Windows into a <strong>Screen Buffer</strong> according to their screen coordinates.</p>
</li>
<li>
<p>The Screen Buffer is rendered to our screen by the X11 Service, talking to the <strong>Linux Display Driver</strong>.</p>
</li>
<li>
<p>Any <strong>keyboard and mouse input</strong> is captured by the X11 Service, and forwarded to the programs.</p>
</li>
</ol>
<p><em>Why is X11 so complex? So many hops?</em></p>
<p>Because X11 was designed for Distributed Computing Systems.</p>
<p>Here's how I used (abused?) X11R4 at <a href="http://srg.cs.illinois.edu/">UIUC Systems Research Group</a> way back in 1990 (30 years ago!)...</p>
<p><img src="https://lupyuen.github.io/images/wayland-uiuc.png" alt="Distributed X11 System" /></p>
<p>Thankfully things are a lot simpler now, lemme explain...</p>
<h1 id="wayland-on-ubuntu-touch" class="section-header"><a href="#wayland-on-ubuntu-touch">2 Wayland on Ubuntu Touch</a></h1>
<p><em>Do we need overlapping or tiled windows on PinePhone?</em></p>
<p><em>Do we need to need to decorate PinePhone windows with a title bar and minimise / maximise / close buttons?</em></p>
<p><em>Do we even need any windows on PinePhone?</em></p>
<p>No! Because each PinePhone app takes control of the entire screen!</p>
<p>PinePhone uses a simpler Graphical Display Service: the <a href="https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)#Wayland_compositors"><strong>Wayland Compositor</strong></a>.</p>
<p>Let's hunt for the Wayland Compositor on PinePhone...</p>
<p><img src="https://lupyuen.github.io/images/wayland-compositor.png" alt="Wayland Compositor on PinePhone" /></p>
<p>That's the Wayland Compositor... A <strong>262 KB</strong> executable named <code>unity-system-compositor</code>. </p>
<p><em>Compare that with the 2.2 MB X11 Server on Pinebook Pro!</em></p>
<p>Here's how the Wayland Compositor controls apps and touchscreen input on PinePhone with Ubuntu Touch...</p>
<p><img src="https://lupyuen.github.io/images/wayland-arch.png" alt="Wayland Architecture" /></p>
<p>(Adapted from <a href="https://wayland.freedesktop.org/architecture.html">&quot;Wayland Architecture&quot;</a> and <a href="https://en.wikipedia.org/wiki/EGL_(API)">&quot;EGL API&quot;</a>)</p>
<ol>
<li>
<p>At the top we have the apps running on our phone: <strong>Terminal, Editor, Web Browser</strong>.</p>
<p>Since each app runs fullscreen, only the active app will be rendered.</p>
<p>When then app starts, it queries the <strong>Wayland Compositor</strong> for the graphical display interfaces available. (They talk via a <a href="https://en.wikipedia.org/wiki/Unix_file_types#Socket">Linux socket file</a>: <code>/run/user/32011/wayland-0</code>)</p>
</li>
<li>
<p>Wayland Compositor returns the <a href="https://en.wikipedia.org/wiki/EGL_(API)"><strong>EGL Interface</strong></a> to the app.</p>
</li>
<li>
<p>App calls the EGL Interface to <a href="https://en.wikipedia.org/wiki/OpenGL"><strong>render OpenGL graphics</strong></a> directly to the <strong>Linux Display Driver</strong>.</p>
</li>
<li>
<p>Linux Display Driver forwards the OpenGL rendering commands to the <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit"><strong>GPU to update the screen</strong></a>.</p>
</li>
<li>
<p>Any <strong>touchscreen input</strong> is captured by the Wayland Compositor, and forwarded to the active app.</p>
</li>
</ol>
<p>Wayland looks so much simpler and faster than X11!</p>
<p><em>Wayland is designed for OpenGL and GPUs?</em></p>
<p>Yes! And I lied about Wayland being New Underwear... Wayland is not really that New!</p>
<p>Wayland was first released in 2008 (<a href="https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)">11 years ago</a>)... Yet it was designed around OpenGL and GPUs, the same tech that powers our beautiful games today. (<a href="https://youtu.be/DNBk9hnPkTY">And websites too</a>)</p>
<p>Read on to learn how to render our own OpenGL graphics with Wayland and Ubuntu Touch on PinePhone...</p>
<p><img src="https://lupyuen.github.io/images/wayland-egl.jpg" alt="Rendering a yellow rectangle with Wayland and OpenGL on PinePhone" /></p>
<p><em>Rendering a yellow rectangle with Wayland and OpenGL on PinePhone</em></p>
<h1 id="render-opengl-graphics-with-wayland" class="section-header"><a href="#render-opengl-graphics-with-wayland">3 Render OpenGL Graphics with Wayland</a></h1>
<p>Here's the function that calls OpenGL to render the yellow box above: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L44-L60"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Render the OpenGL ES2 display
static void render_display() {
    puts(&quot;Rendering display...&quot;);

    //  Fill the rectangular region with yellow
    glClearColor(
        1.0,  //  Red
        1.0,  //  Green
        0.0,  //  Blue
        1.0   //  Alpha
    );
    glClear(GL_COLOR_BUFFER_BIT);

    // Render now
    glFlush();
}
</code></pre>
<p><code>render_display()</code> looks exactly like normal OpenGL, and it works on PinePhone with Wayland! (Thanks to Ubuntu Touch)</p>
<p>Two things to note...</p>
<ol>
<li>
<p>PinePhone supports a popular subset of OpenGL, known as <a href="https://en.wikipedia.org/wiki/OpenGL_ES"><strong>OpenGL for Embedded Systems</strong></a> Version 2.0.</p>
<p>OpenGL ES is optimised for Embedded Devices. OpenGL ES is used by many mobile and console games today.</p>
</li>
<li>
<p>To render OpenGL ES graphics, we need to get the OpenGL ES Context and Window Surface from Wayland</p>
</li>
</ol>
<p>Before calling <code>render_display()</code>, we fetch the OpenGL Window Surface from Wayland like so: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L167-L189"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">static struct wl_egl_window *egl_window;  //  Wayland EGL Window
static EGLSurface egl_surface;            //  EGL Surface

/// Create the OpenGL window and render it
static void create_window(void) {
    //  Create an EGL Window from a Wayland Surface 
    egl_window = wl_egl_window_create(surface, WIDTH, HEIGHT);
    assert(egl_window != EGL_NO_SURFACE);  //  Failed to create OpenGL Window

    //  Create an OpenGL Window Surface for rendering
    egl_surface = eglCreateWindowSurface(egl_display, egl_conf,
        egl_window, NULL);
    assert(egl_surface != NULL);  //  Failed to create OpenGL Window Surface

    //  Set the current rendering surface
    EGLBoolean madeCurrent = eglMakeCurrent(egl_display, egl_surface,
        egl_surface, egl_context);
    assert(madeCurrent);  //  Failed to set rendering surface

    //  Render the display
    render_display();

    //  Swap the display buffers to make the display visible
    EGLBoolean swappedBuffers = eglSwapBuffers(egl_display, egl_surface);
    assert(swappedBuffers);  //  Failed to swap display buffers
}
</code></pre>
<p>Functions named <code>wl_egl_...</code> are provided by the Wayland EGL Interface.  Functions named <code>egl...</code> come from the cross-platform <a href="https://docs.mesa3d.org/egl.html#:%7E:text=The%20main%20library%20(%20libEGL%20)%20is,directly%20dispatched%20to%20the%20drivers.">Mesa 3D Graphics Library</a>.</p>
<p><em>EGL vs OpenGL... What's the difference?</em></p>
<p>In Wayland, EGL is the Enabler for OpenGL. </p>
<p>Wayland only understands EGL and it will gladly hand us EGL objects... But it's up to us to transform EGL into OpenGL for rendering.</p>
<p>In the code above, we take a Wayland Surface <code>surface</code> and transform it into an EGL Window <code>egl_window</code>...</p>
<pre><code class="language-c">    //  Create an EGL Window from a Wayland Surface 
    egl_window = wl_egl_window_create(surface, WIDTH, HEIGHT);
</code></pre>
<p>Then we create an OpenGL Window Surface <code>egl_surface</code> from that EGL Window...</p>
<pre><code class="language-c">    //  Create an OpenGL Window Surface for rendering
    egl_surface = eglCreateWindowSurface(egl_display, egl_conf,
        egl_window, NULL);
</code></pre>
<p>And we begin the OpenGL rendering...</p>
<pre><code class="language-c">    //  Set the current rendering surface
    EGLBoolean madeCurrent = eglMakeCurrent(egl_display, egl_surface,
        egl_surface, egl_context);

    //  Render the display
    render_display();

    //  Swap the display buffers to make the display visible
    eglSwapBuffers(egl_display, egl_surface);
</code></pre>
<p>Here's how we create a Wayland Region for OpenGL rendering: <a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L103-L112"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">static struct wl_region *region;  //  Wayland Region

/// Create an opaque region for OpenGL rendering
static void create_opaque_region(void) {
    puts(&quot;Creating opaque region...&quot;);

    region = wl_compositor_create_region(compositor);
    assert(region != NULL);  //  Failed to create EGL Region

    wl_region_add(region, 0, 0, WIDTH, HEIGHT);
    wl_surface_set_opaque_region(surface, region);
}
</code></pre>
<p>TODO</p>
<p>Here's how we get the OpenGL Context...</p>
<p><a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L113-L165"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Wayland EGL Interfaces for OpenGL Rendering
static EGLDisplay egl_display;  //  EGL Display
static EGLConfig  egl_conf;     //  EGL Configuration
static EGLContext egl_context;  //  EGL Context

/// Init the EGL Interface
static void init_egl(void) {
    puts(&quot;Init EGL...&quot;);

    //  Attributes for our EGL Display
    EGLint config_attribs[] = {
        EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
        EGL_RED_SIZE,        8,
        EGL_GREEN_SIZE,      8,
        EGL_BLUE_SIZE,       8,
        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
        EGL_NONE
    };
    static const EGLint context_attribs[] = {
        EGL_CONTEXT_CLIENT_VERSION, 2,
        EGL_NONE
    };

    //  Get the EGL Display
    egl_display = eglGetDisplay((EGLNativeDisplayType) display);
    assert(egl_display != EGL_NO_DISPLAY);  //  Failed to get EGL Display

    //  Init the EGL Display
    EGLint major, minor;
    EGLBoolean egl_init = eglInitialize(egl_display, &amp;major, &amp;minor);
    assert(egl_init);  //  Failed to init EGL Display
    printf(&quot;EGL major: %d, minor %d\n&quot;, major, minor);

    //  Get the EGL Configurations
    EGLint count, n;
    eglGetConfigs(egl_display, NULL, 0, &amp;count);
    printf(&quot;EGL has %d configs\n&quot;, count);
    EGLConfig *configs = calloc(count, sizeof *configs);
    eglChooseConfig(egl_display, config_attribs,
        configs, count, &amp;n);

    //  Choose the first EGL Configuration
    for (int i = 0; i &lt; n; i++) {
        EGLint size;
        eglGetConfigAttrib(egl_display, configs[i], EGL_BUFFER_SIZE, &amp;size);
        printf(&quot;Buffer size for config %d is %d\n&quot;, i, size);
        eglGetConfigAttrib(egl_display, configs[i], EGL_RED_SIZE, &amp;size);
        printf(&quot;Red size for config %d is %d\n&quot;, i, size);
        egl_conf = configs[i];
        break;
    }
    assert(egl_conf != NULL);  //  Failed to get EGL Configuration

    //  Create the EGL Context based on the EGL Display and Configuration
    egl_context = eglCreateContext(egl_display, egl_conf,
        EGL_NO_CONTEXT, context_attribs);
    assert(egl_context != NULL);  //  Failed to create EGL Context
}
</code></pre>
<p>To learn more about EGL, check out <a href="https://jan.newmarch.name/Wayland/EGL/">&quot;Programming Wayland Clients&quot;</a></p>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L64-L98"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Wayland Interfaces
static struct wl_surface       *surface;       //  Wayland Surface
static struct wl_shell_surface *shell_surface; //  Wayland Shell Surface

/// Connect to Wayland Compositor and render OpenGL graphics
int main(int argc, char **argv) {
    //  Get interfaces for Wayland Compositor and Wayland Shell
    get_server_references();
    assert(compositor != NULL);  //  Failed to get Wayland Compositor
    assert(shell != NULL);       //  Failed to get Wayland Shell

    //  Create a Wayland Surface for rendering
    surface = wl_compositor_create_surface(compositor);
    assert(surface != NULL);  //  Failed to create Wayland Surface

    //  Get the Wayland Shell Surface for rendering
    shell_surface = wl_shell_get_shell_surface(shell, surface);
    assert(shell_surface != NULL);

    //  Set the Shell Surface as top level
    wl_shell_surface_set_toplevel(shell_surface);

    //  Create an opaque region for rendering
    create_opaque_region();

    //  Init Wayland EGL
    init_egl();

    //  Create the OpenGL Window and render OpenGL graphics
    create_window();

    //  Handle all Wayland Events in the Event Loop
    while (wl_display_dispatch(display) != -1) {}

    //  Disconnect from the Wayland Display
    wl_display_disconnect(display);
    puts(&quot;Disconnected from display&quot;);
    return 0;
}
</code></pre>
<p>TODO</p>
<p>Building a Wayland app is refreshingly simple (if you're used to GDK, Qt and SDL).</p>
<p>Here'a how we build the app in <code>egl.c</code> on a Linux machine (that has the Wayland, EGL and OpenGL ES2 libraries installed)...</p>
<pre><code class="language-bash"># Build the Wayland EGL app
gcc \
    -g \
    -o egl \
    egl.c \
    -Wl,-Map=egl.map \
    -L/usr/lib/aarch64-linux-gnu/mesa-egl \
    -lwayland-client \
    -lwayland-server \
    -lwayland-egl \
    -lEGL \
    -lGLESv2
</code></pre>
<pre><code class="language-bash"># Start the Weston Wayland Compositor on our computer with the PinePhone screen dimensions
weston --width=720 --height=1398 &amp;

# Run the Wayland EGL app
./egl
</code></pre>
<p>And we'll see this...</p>
<p><img src="https://lupyuen.github.io/images/wayland-westonegl.png" alt="EGL App running with Wayland Weston Compositor on Pinebook Pro" /></p>
<p>We learn in a while how to build and run the app on PinePhone.</p>
<p>The Wayland EGL code in this article was adapted from https://jan.newmarch.name/Wayland/EGL/ </p>
<h1 id="fetch-wayland-interfaces" class="section-header"><a href="#fetch-wayland-interfaces">4 Fetch Wayland Interfaces</a></h1>
<p><a href="https://github.com/lupyuen/pinephone-mir/blob/master/egl.c#L194-L251"><code>pinephone-mir/egl.c</code></a></p>
<pre><code class="language-c">/// Wayland Interfaces
static struct wl_display       *display;       //  Wayland Display
static struct wl_compositor    *compositor;    //  Wayland Compositor
static struct wl_shell         *shell;         //  Wayland Shell

/// Callbacks for interfaces returned by Wayland Service
static const struct wl_registry_listener registry_listener = {
    global_registry_handler,
    global_registry_remover
};

/// Connect to Wayland Service and fetch the interfaces for Wayland Compositor and Wayland Shell
static void get_server_references(void) {
    puts(&quot;Getting server references...&quot;);
    display = wl_display_connect(NULL);
    if (display == NULL) {
        fprintf(stderr, &quot;Failed to connect to display\n&quot;);
        exit(1);
    }
    puts(&quot;Connected to display&quot;);

    //  Get the Wayland Registry
    struct wl_registry *registry = wl_display_get_registry(display);
    assert(registry != NULL);  //  Failed to get Wayland Registry

    //  Add Registry Callbacks to handle interfaces returned by Wayland Service
    wl_registry_add_listener(registry, &amp;registry_listener, NULL);

    //  Wait for Registry Callbacks to fetch Wayland Interfaces
    wl_display_dispatch(display);
    wl_display_roundtrip(display);

    //  We should have received interfaces for Wayland Compositor and Wayland Shell
    assert(compositor != NULL);  //  Failed to get Wayland Compositor
    assert(shell != NULL);       //  Failed to get Wayland Shell
}

/// Callback for interfaces returned by Wayland Service
static void global_registry_handler(void *data, struct wl_registry *registry, uint32_t id,
    const char *interface, uint32_t version) {
    printf(&quot;Got interface %s id %d\n&quot;, interface, id);

    if (strcmp(interface, &quot;wl_compositor&quot;) == 0) {
        //  Bind to Wayland Compositor Interface
        compositor = wl_registry_bind(registry, id,
            &amp;wl_compositor_interface,   //  Interface Type
            1);                         //  Interface Version
    } else if (strcmp(interface, &quot;wl_shell&quot;) == 0){
        //  Bind to Wayland Shell Interface
        shell = wl_registry_bind(registry, id,
            &amp;wl_shell_interface,        //  Interface Type
            1);                         //  Interface Version
    }
}

/// Callback for removed interfaces
static void global_registry_remover(void *data, struct wl_registry *registry, uint32_t id) {
    printf(&quot;Removed interface id %d\n&quot;, id);
}
</code></pre>
<p>Now let's render a simple texture with Wayland and OpenGL...</p>
<p><img src="https://lupyuen.github.io/images/wayland-egl2.jpg" alt="Rendering a simple texture with Wayland and OpenGL on PinePhone" /></p>
<p><em>Rendering a simple texture with Wayland and OpenGL on PinePhone</em></p>
<h1 id="render-opengl-texture-with-wayland" class="section-header"><a href="#render-opengl-texture-with-wayland">5 Render OpenGL Texture with Wayland</a></h1>
<p>TODO</p>
<p>The OpenGL Texture code in this article was adapted from https://github.com/danginsburg/opengles-book-samples</p>
<h1 id="port-lvgl-to-wayland" class="section-header"><a href="#port-lvgl-to-wayland">6 Port LVGL to Wayland</a></h1>
<p>TODO</p>
<p>SDL, GTK, Qt are complex because they handle X11 legacy stuff</p>
<p>SDL and GTK will work on Wayland... but needs X11 compatibilty!</p>
<p>I applaud the maintainers of x11, gtk, qt, sdl because every new release needs to support so many legacy features. Kudos!</p>
<p>What if we could start from scratch, drop the legacy stuff, and build a ui toolkit for Wayland and opengl?</p>
<p>Lvgl is that experiment that we're undertaking today</p>
<p>Rust wrapper for lvgl</p>
<h1 id="overcome-apparmor-security-on-ubuntu-touch" class="section-header"><a href="#overcome-apparmor-security-on-ubuntu-touch">7 Overcome AppArmor Security on Ubuntu Touch</a></h1>
<p>TODO</p>
<p>Why AppArmor?</p>
<h1 id="start-ssh-on-pinephone" class="section-header"><a href="#start-ssh-on-pinephone">8 Start SSH on PinePhone</a></h1>
<p>To start SSH on PinePhone, open the Terminal app.</p>
<p>Create a file named <code>a</code>...</p>
<pre><code class="language-bash">nano a
</code></pre>
<p>Type this script into the <code>a</code> file...</p>
<pre><code class="language-bash">#!/bin/sh
# Script to start SSH service and show IP address

# Start SSH service
sudo service ssh start

# Show IP address
ifconfig | \
    grep -v &quot;127.0.0.1&quot; | \
    grep &quot;inet addr:&quot;

# Ping repeatedly to keep WiFi alive
ping google.com
</code></pre>
<p>Save the file and exit <code>nano</code>.</p>
<p>TODO: How to install the script on PinePhone via SD card or Bluetooth</p>
<p>When we're ready do coding on PinePhone, enter this at the command line...</p>
<pre><code class="language-bash">. a 
</code></pre>
<p>(There's a space between &quot;<code>.</code>&quot; and &quot;<code>a</code>&quot;)</p>
<p>The script starts the SSH Service and displays the IP address for PinePhone...</p>
<p><img src="https://lupyuen.github.io/images/wayland-ssh.jpg" alt="Starting SSH Service on PinePhone" /></p>
<p>We'll connect to PinePhone at the IP adddress indicated by <code>inet addr</code>. </p>
<p>Tap on <code>Ctrl-C</code> to stop the <code>ping</code>.</p>
<p>TODO: How to install SSH key on PinePhone via SD card or Bluetooth</p>
<p>When we press PinePhone's power button to switch off PinePhone, we'll see ths amusing message from olden times...</p>
<p><img src="https://lupyuen.github.io/images/wayland-halt.jpg" alt="Powering off PinePhone" /></p>
<h1 id="build-lvgl-on-pinephone" class="section-header"><a href="#build-lvgl-on-pinephone">9 Build LVGL on PinePhone</a></h1>
<p>TODO</p>
<h1 id="run-lvgl-on-pinephone" class="section-header"><a href="#run-lvgl-on-pinephone">10 Run LVGL on PinePhone</a></h1>
<p>TODO</p>
<p>Mir Server Log may be found on PinePhone here...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="op">/</span><span class="ident">home</span><span class="op">/</span><span class="ident">phablet</span><span class="op">/</span>.<span class="ident">cache</span><span class="op">/</span><span class="ident">upstart</span><span class="op">/</span><span class="ident">unity8</span>.<span class="ident">log</span></pre></div>
<p>Copy the log to our machine like this...</p>
<pre><code class="language-bash">scp -i ~/.ssh/pinebook_rsa phablet@192.168.1.10:/home/phablet/.cache/upstart/u
</code></pre>
<p><img src="https://lupyuen.github.io/images/wayland-weston.png" alt="PinePhone Wayland App tested on Pinebook Pro" /></p>
<h1 id="build-and-test-pinephone-wayland-apps-on-pinebook-pro" class="section-header"><a href="#build-and-test-pinephone-wayland-apps-on-pinebook-pro">11 Build and Test PinePhone Wayland Apps on Pinebook Pro</a></h1>
<p>Here's how we can build and test PinePhone Wayland Apps on Pinebook Pro...</p>
<pre><code class="language-bash"># Create a symbolic link for the OpenGL ES2 shared library that will be used for the Wayland build
sudo mkdir -p /usr/lib/aarch64-linux-gnu/mesa-egl/
sudo ln -s /usr/lib/libGLESv2.so /usr/lib/aarch64-linux-gnu/mesa-egl/libGLESv2.so.2

# Build the Wayland executable
make

# Start the Weston Wayland Compositor on Pinebook Pro with the PinePhone screen dimensions
weston --width=720 --height=1398 &amp;

# Run the Wayland executable
wayland/lvgl
</code></pre>
<h1 id="wayland-gotchas" class="section-header"><a href="#wayland-gotchas">12 Wayland Gotchas</a></h1>
<p>TODO</p>
<p>GPU on X11:</p>
<p>https://qoto.org/@lupyuen/104541068127168291</p>
<p>GNOME and GTK on Wayland:</p>
<p>https://mastodon.social/@ebassi/104511735257435944</p>
<p>UBports on Mir:</p>
<p>https://twitter.com/UBports/status/1282935946711904257?s=09</p>
<p>https://twitter.com/UBports/status/1282934927806398464?s=09</p>
<p>https://twitter.com/UBports/status/1282936886311428096?s=09</p>
<p>Wayland on Xfce:</p>
<p>https://twitter.com/XfceNation/status/1284842929895301120?s=09</p>
<p>https://twitter.com/XfceNation/status/1284854254092513285?s=09</p>
<p>Mir / Lomiri / Unity8's complicated history:</p>
<p>https://www.phoronix.com/scan.php?page=news_item&amp;px=Mir-2019-Kicking</p>
<p>https://www.phoronix.com/scan.php?page=news_item&amp;px=Unity-8-Renamed-To-Lomiri</p>
<h1 id="what-i-like-about-ubuntu-touch-on-pinephone" class="section-header"><a href="#what-i-like-about-ubuntu-touch-on-pinephone">13 What I like about Ubuntu Touch on PinePhone</a></h1>
<p>TODO</p>
<p>AppArmor is good, because iOS and Android have similar apps security</p>
<p>Read-only file system is good (system files are read-only by default, user files are read-write). Helps to prevent security holes. (Even PineTime has a read-only Flash ROM)</p>
<p>Why is Qt supported on Ubuntu Touch and not GTK? Because building a Linux mobile app requires mobile-friendly widgets.</p>
<p>I think Qt has more mobile-friendly widgets, even through the internal plumbing is way too complicated.</p>
<p>When I get GTK running on Ubuntu Touch, I will face the same problem with widgets. And I have to make GTK widgets look and feel consistent with Qt / Ubuntu Touch widgets.</p>
<p>Older kernel base in Ubuntu Touch... I don't do kernel hacking much so it doesn't matter to me.</p>
<p>I think for mobiles we only need to support a few common chipsets, so an older kernel is probably fine.</p>
<p>That explains why Raspberry Pi 4 isn't supported by Ubuntu Touch... The hardware is just too new.</p>
<p>The issues I'm struggling with now... Wayland, GTK3, ... are actually really old stuff. Updating the kernel won't help.</p>
<p>Ubuntu Touch is pure Wayland, none of the legacy X11 stuff. Xwayland is not even there (unless you use the Libertine containers ugh).</p>
<p>The pure Wayland environment causes GTK to break, because GTK assumes some minimal X11 support (i.e. Xwayland).</p>
<p>So Ubuntu Touch is not really that bad for PinePhone... It's just painful for building non-Qt apps. üôÇ</p>
<h1 id="further-reading" class="section-header"><a href="#further-reading">14 Further Reading</a></h1>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/bloc">&quot;Flutter State Management with Bloc for PineTime Companion App&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/companion">&quot;Convert Go to Flutter and Dart for PineTime Companion App&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/flutter">&quot;Your First Bluetooth Low Energy App with Flutter&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/gotk3">&quot;Your First GTK App with Go and VSCodium&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">&quot;MCUBoot Bootloader for PineTime Smart Watch (nRF52)&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu">&quot;Firmware Update over Bluetooth Low Energy on PineTime Smart Watch&quot;</a></em></p>
<p><em><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfutest">&quot;Wireless Firmware Update In Action on PineTime Smart Watch (nRF52)&quot;</a></em></p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/README.md">Check out the other PineTime articles</a></p>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>

    
</body>
</html>