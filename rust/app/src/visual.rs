//! This program was automatically generated by Visual Embedded Rust. Don't edit here!
extern crate macros as mynewt_macros;   //  Declare the Mynewt Procedural Macros library
use mynewt_macros::infer_type;          //  Import Mynewt procedural macros
use mynewt::{
  result::*,              // Import Mynewt API Result and Error types
  sys::console,           // Import Mynewt Console API
};
use druid::{
  AppLauncher, Data, EventCtx, LocalizedString, Widget, WindowDesc,
  widget::{
      Align, Button, Column, Label, Padding,
  },
  argvalue::ArgValue,
  env::Env,
};

/// Application State
#[infer_type]  //  Infer the missing types
#[derive(Clone, Data, Default)]
struct State {
    count: _,
}

/// Will be run upon startup to launch the app
#[infer_type]  //  Infer the missing types
pub fn on_start() -> MynewtResult<()> {
    console::print("on_start\n");
    //  Build a new window
    let main_window = WindowDesc::new(ui_builder);
    //  Create application state
    let state = State::default();
    state.count = 0;

    //  Launch the window with the application state
    AppLauncher::with_window(main_window)
        .use_simple_logger()
        .launch(state)
        .expect("launch failed");
    //  Return success to `main()` function
    Ok(())
}

/// Build the UI for the window
#[infer_type]  //  Infer the missing types
fn ui_builder() -> impl Widget {  //  `State` is the Application State
    console::print("Rust UI builder\n"); console::flush();
    //  Create a line of text
    let my_label_text = LocalizedString::new("hello-counter")
        .with_arg("count", on_my_label_show.into());  //  Call `on_my_label_show` to get label text
    //  Create a label widget `my_label`
    let my_label = Label::new(my_label_text);
    //  Create a button widget `my_button`
    let my_button = Button::new("increment", on_my_button_press.into());  //  Call `on_my_button_press` when pressed

    //  Create a column
    let mut col = Column::new();
    //  Add the label widget to the column, centered with padding
    col.add_child(
        Align::centered(
            Padding::new(5.0,
                my_label
            )
        ),
        1.0
    );
    //  Add the button widget to the column, with padding
    col.add_child(
        Padding::new(5.0,
            my_button
        ),
        1.0
    );
    //  Return the column containing the widgets
    col
}

/// Callback function that will be called to create the formatted text for the label `my_label`
#[infer_type]  //  Infer the missing types
fn on_my_label_show(state: _, env: _) -> MynewtResult {
    console::print("on_my_label_show\n");
    Ok(state.count.into())
}

/// Callback function that will be called when the button `my_button` is pressed
#[infer_type]  //  Infer the missing types
fn on_my_button_press(ctx: _, state: _, env: _) -> MynewtResult<()> {
    console::print("on_my_button_press\n");
    state.count = state.count + 1;
    Ok(())
}

///  Callback function that will be called to create the formatted text for the label
type LabelFn = fn(state: &State, env: &Env) -> ArgValue;
type LabelMynewtFn = fn(state: &State, env: &Env) -> MynewtResult<ArgValue>;

///  Callback function that will be called when the button is tapped
type ButtonFn = fn(ctx: &mut EventCtx<State>, state: &mut State, env: &Env);
type ButtonMynewtFn = fn(ctx: &mut EventCtx<State>, state: &mut State, env: &Env) -> MynewtResult<()>;

/// Cast `LabelMynewtFn` to `LabelFn`
impl From<LabelMynewtFn> for LabelFn {
    /// Cast `LabelMynewtFn` to `LabelFn`
    fn from(err: LabelMynewtFn) -> Self {
        on_label_show
    }
}

/// Cast `ButtonMynewtFn` to `ButtonFn`
impl From<ButtonMynewtFn> for ButtonFn {
    /// Cast `ButtonMynewtFn` to `ButtonFn`
    fn from(err: ButtonMynewtFn) -> Self {
        on_button_press
    }
}

/// TODO: Placeholders
fn on_label_show(state: &State, env: &Env) -> ArgValue {
    let result = on_my_label_show(state, env);
    match result {
        Ok(argValue) => argValue,
        Err() => 0  //  TODO
    }
}

/// TODO: Placeholders
fn on_button_press(ctx: &mut EventCtx<State>, state: &mut State, env: &Env) {
    let result = on_my_button_press(ctx, state, env);
    match result {
        Ok() => (),
        Err() => ()  //  TODO
    }
}